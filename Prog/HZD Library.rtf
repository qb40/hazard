{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe1028{\fonttbl{\f0\fscript\fprq2\fcharset0 Comic Sans MS;}{\f1\froman\fprq2\fcharset129 New Gulim;}{\f2\froman\fprq2\fcharset0 Times New Roman;}}
{\*\generator Msftedit 5.41.21.2508;}\viewkind4\uc1\pard\nowidctlpar\b\f0\fs20 -----------------------------------------------------------------------------\par
\pard\nowidctlpar\ri-1800\fs96 HAZARD LIBRARY\par
\pard\nowidctlpar\fs20 -----------------------------------------------------------------------------\par
First version\tab :\tab 25.3.2010\par
Developed for\tab :\tab QuickBasic 4.5 (or similar)\par
Use\tab\tab :\tab Game/Software Programming\par
Developed by\tab :\tab Subhajit Sahu\par
-----------------------------------------------------------------------------\par
\par
Have fun with DirectQB, and remember to visit the\par
Official DirectQB website\par
\par
                          http://www.ecplusplus.com\par
\par
If you have any questions, post a message on the wwwboard there, and you'll\par
get a reply!\par
\par
\par
=============================================================================\par
\par
\par
TABLE OF CONTENTS\par
\par
1     Introduction to DirectQB\par
  1.1   Legal stuff\par
  1.2   What is DirectQB\par
  1.3   System requirements\par
  1.4   Features\par
  1.5   Installing the library\par
  1.6   Basic concepts\par
  1.7   Limits of the library\par
2     Functions reference\par
        DQBangle FUNCTION\par
        DQBasc FUNCTION\par
        DQBbgtri SUB\par
        DQBbox SUB\par
        DQBboxf SUB\par
        DQBbPut SUB\par
        DQBbtri SUB\par
        DQBbttri SUB\par
        DQBchDir FUNCTION\par
        DQBclearLayer SUB\par
        DQBclose SUB\par
        DQBcloseDataFile SUB\par
        DQBcloseFLI SUB\par
        DQBcollide FUNCTION\par
        DQBcollideOnLayer FUNCTION\par
        DQBcopyBlendLayer SUB\par
        DQBcopyHitLayer SUB\par
        DQBcopyLayer SUB\par
        DQBcopyTransLayer SUB\par
        DQBcreateBMap FUNCTION\par
        DQBdir$ FUNCTION\par
        DQBdrive$ FUNCTION\par
        DQBellipse SUB\par
        DQBerror$ FUNCTION\par
        DQBfadeIn SUB\par
        DQBfadeStepIn SUB\par
        DQBfadeStepTo SUB\par
        DQBfadeTo SUB\par
        DQBfilterBox SUB\par
        DQBfindCol FUNCTION\par
        DQBfindPalCol FUNCTION\par
        DQBfpu SUB\par
        DQBfPut SUB\par
        DQBframeReady FUNCTION\par
        DQBfttri SUB\par
        DQBget SUB\par
        DQBgetBMap FUNCTION\par
        DQBgetCol SUB\par
        DQBgetPal SUB\par
        DQBgline SUB\par
        DQBgtri SUB\par
        DQBhPut SUB\par
        DQBid$ FUNCTION\par
        DQBinit FUNCTION\par
        DQBinitText SUB\par
        DQBinitVGA SUB\par
        DQBinkey$ FUNCTION\par
        DQBinstallKeyboard SUB\par
        DQBinstallSB FUNCTION\par
        DQBinUse FUNCTION\par
        DQBjoyDetected FUNCTION\par
        DQBjoyFire FUNCTION\par
        DQBjoyMove FUNCTION\par
        DQBjoyX FUNCTION\par
        DQBjoyY FUNCTION\par
        DQBkey FUNCTION\par
        DQBlen FUNCTION\par
        DQBline SUB\par
        DQBloadBMap FUNCTION\par
        DQBloadFont FUNCTION\par
        DQBloadImage FUNCTION\par
        DQBloadRawSound FUNCTION\par
        DQBloadSound FUNCTION\par
        DQBmapLayer FUNCTION\par
        DQBmouseDetected FUNCTION\par
        DQBmouseHide SUB\par
        DQBmouseLB FUNCTION\par
        DQBmouseRB FUNCTION\par
        DQBmouseShow SUB\par
        DQBmouseX FUNCTION\par
        DQBmouseY FUNCTION\par
        DQBmPut SUB\par
        DQBnumDrives FUNCTION\par
        DQBopenDataFile FUNCTION\par
        DQBopenFLI FUNCTION\par
        DQBpaint SUB\par
        DQBpalOff SUB\par
        DQBpalRotate SUB\par
        DQBpath$ FUNCTION\par
        DQBpauseSound SUB\par
        DQBpeek SUB\par
        DQBplayFLI FUNCTION\par
        DQBplayFLIstep SUB\par
        DQBplaySound SUB\par
        DQBpoint FUNCTION\par
        DQBpoke SUB\par
        DQBpollJoy SUB\par
        DQBpPut SUB\par
        DQBprint SUB\par
        DQBprints SUB\par
        DQBpset SUB\par
        DQBput SUB\par
        DQBputOver SUB\par
        DQBreadBit FUNCTION\par
        DQBreadKey FUNCTION\par
        DQBremoveBMap SUB\par
        DQBremoveKeyboard SUB\par
        DQBremoveSB SUB\par
        DQBresetBit FUNCTION\par
        DQBresetJoy SUB\par
        DQBresetMouse SUB\par
        DQBresumeSound SUB\par
        DQBrPut SUB\par
        DQBsaveBMap FUNCTION\par
        DQBsaveImage FUNCTION\par
        DQBscroll SUB\par
        DQBscrollArea SUB\par
        DQBsetBaseLayer FUNCTION\par
        DQBsetBIOSfont SUB\par
        DQBsetBit FUNCTION\par
        DQBsetBMap SUB\par
        DQBsetClipBox SUB\par
        DQBsetCol SUB\par
        DQBsetCollideMethod SUB\par
        DQBsetDrive SUB\par
        DQBsetFont SUB\par
        DQBsetFontTexture SUB\par
        DQBsetFrameRate SUB\par
\tab   DQBsetFreq SUB\par
        DQBsetMousePos SUB\par
        DQBsetMouseRange SUB\par
        DQBsetMouseShape SUB\par
        DQBsetMouseSpeed SUB\par
        DQBsetPal SUB\par
        DQBsetSolidPut SUB\par
        DQBsetTextBackCol SUB\par
        DQBsetTextBMap SUB\par
        DQBsetTextSpacing SUB\par
        DQBsetTextStyle SUB\par
        DQBsetTextureSize SUB\par
        DQBsetTransPut SUB\par
        DQBsetVoiceVol SUB\par
        DQBsetVolume SUB\par
        DQBshiftLeft FUNCTION\par
        DQBshiftRight FUNCTION\par
        DQBsize FUNCTION\par
        DQBsort SUB\par
        DQBsPut SUB\par
        DQBstopVoice SUB\par
        DQBtoggleBit FUNCTION\par
        DQBtPut SUB\par
        DQBtri SUB\par
        DQBttri SUB\par
        DQBunpackBMap FUNCTION\par
        DQBunpackCursor FUNCTION\par
        DQBunpackFont FUNCTION\par
        DQBunpackImage FUNCTION\par
        DQBunpackPal FUNCTION\par
        DQBunpackSound FUNCTION\par
        DQBunpackSprite FUNCTION\par
        DQBunpackUser FUNCTION\par
        DQBver FUNCTION\par
        DQBwait SUB\par
        DQBwaitKey SUB\par
        DQBxPut SUB\par
APPENDIX A    Library constants\par
APPENDIX B    Keyboard scancodes list\par
APPENDIX C    Library file formats\par
APPENDIX D    Known bugs\par
APPENDIX E    Versions history\par
APPENDIX F    Inside library modules\par
APPENDIX G    Error messages\par
Credits and final words\par
\par
-----------------------------------------------------------------------------\par
\par
\par
\par
=============================================================================\par
1.  INTRODUCTION TO DIRECTQB\par
=============================================================================\par
\par
\par
-----------------------------------------------------------------------------\par
1.1 - Legal stuff\par
-----------------------------------------------------------------------------\par
\par
THIS SOFTWARE FOLLOWS THE RULES OF THE FREEWARE CONCEPT: YOU CAN SHARE IT\par
WITH YOUR FRIENDS, AND YOU'RE ENCOURAGED IN DOING SO, BUT THE AUTHOR IS IN NO\par
WAY LIABLE FOR ANY DAMAGES CAUSED BY THE USE OF THIS LIBRARY. IT IS NOT\par
COPYRIGHTED, BUT IF YOU WANT TO MODIFY IT, PLEASE CONTACT ME FIRST.\par
IF YOU USE THE DIRECTQB ROUTINES, PLEASE GIVE CREDITS IN YOUR PROGRAM.\par
\par
\par
-----------------------------------------------------------------------------\par
1.2 - What is DirectQB\par
-----------------------------------------------------------------------------\par
\par
DirectQB is a game programming library entirely written in assembly 386 for\par
QuickBasic 4.5. It has been coded mainly to fill the void in the weak\par
graphics, input and sound capabilities of QB; it works in screen mode 13h\par
(320x200 with 256 colors - the common SCREEN 13 for QB), supports keyboard,\par
mouse and joysticks as input devices, and has a built-in sound engine that\par
works with almost any SB compatible sound card. It really has a lot of\par
features, as you'll discover by reading this manual...\par
\par
\par
-----------------------------------------------------------------------------\par
1.3 - System requirements\par
-----------------------------------------------------------------------------\par
\par
First of all you'll need a copy of QuickBasic 4.5. DirectQB is a quicklibrary,\par
and therefore is made to run only under this programming environment.\par
As DirectQB has been entirely coded in assembly using several advanced 386\par
instructions, a 386 or better CPU is required. EMS is also needed in order\par
to have off-screen buffers (though you can also have them stored in base mem),\par
the so named "layers", as we'll see later. For every layer you need 64 KB of\par
free base or EMS memory; if you don't know what EMS is, or you have problems\par
with it, try adding these lines at the beginning of your CONFIG.SYS file:\par
\par
\par
It is expected that you run into an out of memory error if you call the DQB\par
functions that require extra base memory without calling the SETMEM function\par
first. See the QB online help and the examples on this manual for details on\par
how to use it.\par
\par
Well, so far there are no more requirements to run DirectQB.\par
\par
\par
-----------------------------------------------------------------------------\par
1.4 - Features\par
-----------------------------------------------------------------------------\par
\par
DirectQB version 1.71 has the following features:\par
\par
Graphical features:\par
\par
- Supports 320x200 with 256 colors video mode, with almost unlimited number\par
  of off-screen buffers stored into EMS memory or into conventional memory.\par
  EMS is automatically handled for you by the library\par
- All the functions act on the screen, as well as on the off-screen buffers\par
- Several drawing primitives, including pset, line, gline, ellipse, box,\par
  full box and paint\par
- Fast sprite handling functions, compatible with standard GET and PUT, also\par
  with support for sprite flipping, scaling, roto-zooming and translucency,\par
  and direct sprite drawing from a layer onto another one without requiring\par
  any external QB array\par
- Sprites collision detection with selectable method (bounding box or pixel\par
  perfect), and support for collision layers\par
- Color blending routines to handle up to 10 customizable blender maps,\par
  allowing to create any color combination\par
- Clipping for almost all the graphical functions\par
- Loads and saves images in BSAVE, BMP and PCX format in any size\par
- Plays FLI animation files\par
- Font routines with customizable font set, non-fixed sized fonts support and\par
  custom styles, such as bold, italic, underlined, or a combination of them,\par
  also with support for color blending and textured text\par
- Smooth palette handling with routines to fade the current palette into any\par
  new one as well as into any specified color, and to rotate colors\par
- Multidirectional scrolling for an entire layer or only a portion of it\par
- Transparent screen copy for parallax scrolling effects, blended layer copy\par
  for huge translucency effect\par
- Fast triangle drawing primitives allowing flat-shading, gouraud-shading\par
  and affine texture mapping (also with support for bi-linear filtering),\par
  all with support for color blending\par
\par
Input features:\par
\par
- Custom keyboard interrupt handler that allows to know the state (pressed or\par
  released) of any key at any time\par
- Several keyboard handling functions working under this IRQ handler, to read\par
  a key, to get the ascii code from its scancode, and more\par
- Fast and easy to use joystick routines, with auto detection and auto\par
  calibration, with support for 1 or 2 2-button joysticks or 1 4-button joypad\par
- Mouse handler: the mouse variables (coordinates and buttons status) are\par
  automatically updated when you move the mouse, allowing you to know the\par
  actual mouse state at any time without calling other routines\par
- Mouse routines to change the cursor shape, mouse range, speed and position\par
\par
Sound features:\par
\par
- IRQ driven sound engine for fast and easy sound playback via DMA transfers\par
- Loads and plays sound effects directly from EMS\par
- Supports only 8-bit mono WAV files up to 22000 Hz\par
- Customizable number of channels, from 1 up to 32, for up to 32 sound effects\par
  simultaneously playing\par
- Realtime sound resampling\par
- Customizable volume setting for each of the channels\par
- Customizable master volume setting\par
- Customizable frequency of each channel for special realtime effects\par
\par
Misc features:\par
\par
- Free EMS for personal purposes\par
- Bit handling routines, including read/set/reset/toggle bit, shift left and\par
  right\par
- Routines to find the color in any specified palette that best fits with the\par
  specified red, green and blue hues\par
- Useful routine to find the angle between any two given points\par
- Directory scanning routines, with support for Windows long filenames\par
- Fast multi-purpose records array sorting routine\par
- Internal high precision timer for framerate synchronization\par
- Error messaging system\par
- Datafiles decoding routines, with support for password-crypted data\par
\par
\par
-----------------------------------------------------------------------------\par
1.5 - Installing the library\par
-----------------------------------------------------------------------------\par
\par
The DirectQB library is now shipped as a set of OBJ files, together with their\par
own assembly source code. You should have these files in the library\par
directory:\par
\par
MAIN.OBJ        - Holds main library functions and common variables\par
DRAW.OBJ        - Primitive drawing functions\par
IMAGE.OBJ       - Bsave/BMP/PCX image files handling\par
SPRITE.OBJ      - Special sprites drawing routines\par
BIT.OBJ         - Bit handling routines\par
PALETTE.OBJ     - Palette handling routines\par
FONT.OBJ        - Font functions\par
DISK.OBJ        - Disk and directory handling functions\par
BLENDING.OBJ    - Color blending support module\par
KEYBOARD.OBJ    - Custom keyboard handler routines\par
JOYSTICK.OBJ    - Joystick/joypad support module\par
MOUSE.OBJ       - Mouse handling routines\par
SOUND.OBJ       - Sound engine module\par
3D.OBJ          - Triangle drawing functions\par
DATAFILE.OBJ    - Datafile decoding routines\par
\par
All these files together make the DirectQB library; we'll examine later how\par
to work with them. Additional files you must have in your DQB directory,\par
other than the ASM source files, are:\par
\par
ERRORS.INC      - Include file used by MAIN.ASM; contains error messages\par
README.1ST      - Welcome message\par
FILELIST.TXT    - Complete list of all the files in the DirectQB package\par
DIRECTQB.DOC    - Library manual (this file)\par
DQBMAN.BAS      - DirectQB Library Manager utility\par
DQBMAN.MHL      - Help file for the library manager\par
DQBTOOLS.BAS    - Fonts and mouse cursors editor\par
SMALL.FNT       - Small font created with DQB Tools\par
HITECH.FNT      - Another font created with DQB Tools\par
SCRIPT.FNT      - Script font created with DQB Tools\par
DQBENC.BAS      - Datafile encoder program\par
\par
So, what's up now? You need to create the LIB and QLB files to work with\par
DirectQB under QB 4.5... For this purpose, there's the DirectQB Library\par
Manager utility, which will guide you through this process. Run that program\par
now!\par
\par
Once built, to load the quicklibrary run QB at the DOS prompt by typing:\par
\par
QB/LDQB\par
\par
The IDE will appear, and you'll be able to use the DirectQB functions.\par
\par
DirectQB is made of several OBJ files, this means you can link some of\par
them to create your own quicklibrary, depending on your needs. For example,\par
if you're not planning to use the sound engine, there's no need to include\par
the SOUND.OBJ file in the library... The library manager utility allows you\par
to select each of these DirectQB modules, and creates the following files\par
depending on your selections:\par
\par
DQB.LIB         - Quicklibrary file to be linked to your executable programs\par
DQB.QLB         - Quicklibrary file to be used from inside the QB IDE\par
DIRECTQB.BI     - Include file for the DirectQB library\par
\par
and\par
\par
INSTALL.DAT     - Data on installed modules for library manager\par
INSTALL.LOG     - Installation log file\par
CALLS.BAS       - Used during the library building process, it can be deleted\par
\par
For a list of the functions contained within each of the OBJ modules, take a\par
look at appendix F of this manual.\par
\par
\par
-----------------------------------------------------------------------------\par
1.6 - Basic concepts\par
-----------------------------------------------------------------------------\par
\par
The DirectQB library makes an extensive use of the EMS memory to store off-\par
screen buffers, named "layers", plus sounds. A layers is basically a buffer\par
where you act as you do with the screen. You can draw pixels on it, as well as\par
using all the graphical functions of this library. The EMS memory is\par
automatically handled for you, so all you have to do when calling every\par
graphical function is to specify a layer where to act. To draw something\par
directly to the screen, just use layer number 0 (there's also a constant named\par
VIDEO, as specified into APPENDIX A). You can specify the number of layers to\par
allocate in EMS by calling the DQBinit function, as well as the number of\par
sounds to allocate space for (again in EMS) and the amount of free EMS to\par
preserve for your own purposes; DQBinit must be ALWAYS called before calling\par
any other function of this library, or you'll probably crash your system.\par
Remember also to call DQBclose just before ending your programs; this will\par
free previously allocated memory and it'll turn off the custom keyboard\par
handler and the sound engine if they were on (plus doing other tasks).\par
You can also avoid using EMS, by declaring up to 10 extra layers stored in\par
conventional memory. To setup these "base layers" refer to the DQBsetBaseLayer\par
function.\par
\par
Other than this, you should also keep in mind the following things:\par
\par
\lang1042\f1\u-1806?\lang1033\f0  To speed things up, a lot of checks are skipped, so for example if you\par
  initialize the library with 3 extra layers, DO NOT refer to layer -1 or 4!\par
\par
\lang1042\f1\u-1806?\lang1033\f0  When referring to base layers, be sure you've previously set up them,\par
  because by drawing something onto a layer that has not be configured with\par
  the DQBsetBaseLayer function, you're probably going to crash your system.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  Every graphical function that draws something, except DQBbox, DQBboxf,\par
  DQBfPut and DQBfilterBox supports clipping; this means that every pixel that\par
  lies outside the current clipping box will not be drawn. Clipping box is set\par
  at startup (when calling DQBinit) to (0,0)-(319,199), and it can be changed\par
  at any time by calling the DQBsetClipBox function.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  The sprite data format for library get and many put routines is the same\par
  used by the standard GET and PUT statement; the advantage of using DirectQB\par
  functions is that they act on layers, they support clipping (except DQBfPut)\par
  and they're faster than GET and PUT...\par
\par
\lang1042\f1\u-1806?\lang1033\f0  DQBxPut has the great advantage that it does not require you to store the\par
  sprites into an array and then use this to draw it; this means you save\par
  extra memory for your application, but the bad thing is that DQBxPut is\par
  slower than normal DQBput, and it can handle only sprites with an height up\par
  to 50 pixels.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  The transparent color is color number 0 and cannot be changed.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  When calling a function that requires a box by passing the upper-left\par
  (x1,y1) and lower-right (x2,y2) corners, always remember that it must be\par
  x1<x2 and y1<y2, or you'll probably crash your system.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  By default, when calling DQBprint, the standard BIOS font is used. This can\par
  be changed by calling the DQBsetFont procedure; to restore the BIOS font,\par
  just call DQBsetBIOSfont.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  When referring to a color hue, the red, green and blue components must\par
  always be in the range 0-63, otherwise your system may crash.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  The blending functions all require a blender map. If a blender map has not\par
  been created by DQBcreateBMap, any calls to DQBsetBMap, DQBgetBMap,\par
  DQBloadBMap, DQBsaveBMap, DQBbPut or DQBfilterBox will do nothing; you can\par
  create up to 10 blender maps, and to create them, you'll need free base\par
  memory. See DQBcreateBMap for details.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  Blender maps can map up to 255 foreground color entries; I suggest you to\par
  leave color 0 unmapped, as it should always be used for transparency only.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  Creating a blender map is not an easy job. It depends on the current palette\par
  and, of course, on what your needs are. Once created, it is suggested that\par
  you store your blender map in a file, so that you can load it at any time,\par
  without having to repeat the often slooow process.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  The default collision detection method is the bounding box check.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  You cannot use a framerate lower than 18; lower values will be rounded to\par
  this number. Also, when calling the DQBsetFrameRate function, the system\par
  clock rate is altered, and some programs (like TSRs - SBMIDI for example)\par
  that use the system timer may not run properly.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  When the custom keyboard handler has been turned on by calling the\par
  DQBinstallKeyboard function, the standard QB functions that handle the\par
  keyboard should not be used, or you'll probably lock up your machine.\par
  These functions can be called again only after restoring the old keyboard\par
  handler by calling DQBremoveKeyboard.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  If you want to use the mouse, after calling DQBinit and entering the VGA\par
  mode, it is recommended that you call the DQBmouseReset function. This will\par
  set the default cursor shape and range.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  The mouse status (coordinates and buttons status) is automatically updated\par
  when you move it; you don't have to call any other function to update it.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  For the joystick it's different: before calling the DQBjoyMove and\par
  DQBjoyFire functions, you have to update the internal joystick variables\par
  by calling the DQBpollJoy function. This is a relatively slow operation,\par
  expecially if no joysticks are connected, so be warned.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  The sound engine still has limitations: it supports only 8-bit mono WAV\par
  files for now, and you need a sound card with a DSP 2.00 or better...\par
\par
\lang1042\f1\u-1806?\lang1033\f0  Datafiles can store up to 256 objects; each object is referred to by a\par
  unique ID string, and you can't use the same string for different objects.\par
\par
\lang1042\f1\u-1806?\lang1033\f0  If you have problems decoding an object from a datafile, check your password\par
  first, then if it's correct, check if you referred to the right object, and\par
  if the action you're doing is valid (i.e. check if the image you're trying\par
  to decode isn't stored as a sound)\par
\par
Well, I hope it's all.\par
One last thing: when coding your programs, remember to include this line at\par
the very beginning of your code:\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
This will include the file DIRECTQB.BI in your project; this file contains\par
function and constant declarations used by the library needed to use DirectQB.\par
\par
\par
-----------------------------------------------------------------------------\par
1.7 - Limits of the library\par
-----------------------------------------------------------------------------\par
\par
This library operates only in 320x200 with 256 colors video mode. I really\par
don't know if I'll ever release a hires/hicolor version; I have the knowledge\par
to do it, but this would require a rewrite of most of the library...\par
\par
About the sound engine, only 8-bit mono WAV files are supported for now, and\par
the sampling rate is limited to 22Khz. Why you ask? Well, adding support for\par
higher frequencies requires lot of extra code, and I don't think a game\par
requires so high-quality sounds; in addition, 16-bit sounds would require\par
twice the size to store them, so why bother?\par
The routines are written thinking about speed, so a lot of range checks are\par
skipped; so don't get angry if your computer crashes, if it\par
does so, it's your fault.\par
\par
About the joystick, DirectQB can handle up to two joysticks with 2 buttons\par
each, OR only 1 joystick with 4 buttons. In addition, the routines are mainly\par
written to handle joypads, so they work great with them. Analog joysticks are\par
also supported, but the routines will let you know only if the joystick has\par
been moved in a direction, and not the exact axis positions.\par
\par
Fonts can have a maximum size of 8x8 pixels; the height is the same for all\par
the characters, while the width can vary.\par
\par
Datafiles are a good alternative to having multiple small files in your game\par
directory: the compression is not the best (a simple RLE algorithm is used)\par
but it's really fast. The password and object id strings must have a length\par
of 8 characters maximum; you can also avoid crypting your datafiles, by\par
specifying a null password.\par
\par
For the various file formats used by DirectQB, I strongly suggest you to take\par
a look at appendix C.\par
\par
\par
\par
=============================================================================\par
2.  FUNCTIONS REFERENCE\par
=============================================================================\par
\par
\par
Warning: all the example programs in this section have been tested with the\par
full library release, i.e. all the modules have been included. For efficiency\par
reasons you can remove unused modules at any time with the DQB library manager\par
program.\par
\par
\par
-----------------------------------------------------------------------------\par
DQBangle FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBangle(BYVAL x1,BYVAL y1,BYVAL x2,BYVAL y2)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    x1          X coordinate of first point\par
\lang1042\f1\u-1806?\lang1033\f0    y1          Y coordinate of first point\par
\lang1042\f1\u-1806?\lang1033\f0    x2          X coordinate of second point\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Y coordinate of second point\par
\par
Returns:\par
\par
An INTEGER value holding the angle between the two points, in the range 0-255\par
\par
\par
Description:\par
\par
Do you ever wanted to know the angle an enemy should face to lock for the\par
player in your games? This function lets you know the exact angle between two\par
given points, i.e. what angle the object located at the first point should\par
face to "see" the second one. Returned angle is in the range 0-255, where 0\par
means the second point is above the first, 127 that it's below it, etc...\par
\par
Notes:\par
\par
As DQBangle returns the angle in the range 0-255, you can easily use this\par
function in conjunction with DQBrPut.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE: 'DIRECTQB.BI'\par
\par
' Allocates memory for a simple 32x32 pixels sprite\par
DIM Sprite(514)\par
\par
' Let's initialize the library with one extra layer, no sounds nor free EMS\par
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Checks if a mouse is available\par
IF NOT DQBmouseDetected THEN\par
    ' Mouse not found!\par
    PRINT "This example requires a mouse to run!"\par
    DQBclose\par
    END\par
END IF\par
\par
DQBinitVGA\par
DQBclearLayer 1\par
\par
' Draws our sprite and gets it from a hidden layer\par
DQBline 1, 15, 0, 22, 26, 40\par
DQBline 1, 15, 0, 8, 26, 40\par
DQBline 1, 8, 26, 22, 26, 40\par
DQBpaint 1, 16, 16, 4\par
DQBget 1, 0, 0, 31, 31, VARSEG(Sprite(0)), VARPTR(Sprite(0))\par
\par
' Starts demo\par
DQBresetMouse\par
DQBmouseShow\par
DO\par
  ' Clears layer 1 for double buffering effect\par
  DQBclearLayer 1\par
  \par
  ' Finds angle between the center of our sprite and the mouse cursor\par
  a = DQBangle(160, 100, DQBmouseX, DQBmouseY)\par
\par
  ' Draws rotated sprite\par
  DQBrPut 1, 144, 84, VARSEG(Sprite(0)), VARPTR(Sprite(0)), a, 100\par
\par
  ' Updates the screen\par
  DQBwait 1\par
  DQBmouseHide\par
  DQBcopyLayer 1, VIDEO\par
  DQBmouseShow\par
\par
  ' Ends demo if the user presses a key or any of the mouse buttons\par
  IF DQBmouseLB OR DQBmouseRB OR INKEY$ <> "" THEN EXIT DO\par
LOOP\par
\par
' Ends the program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBasc FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBasc(BYVAL ScanCode,BYVAL ShiftFlag)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    ScanCode    Scancode of the character\par
\lang1042\f1\u-1806?\lang1033\f0    ShiftFlag   See function description\par
\par
Returns:\par
\par
An INTEGER value holding the ascii code number of specified character\par
\par
\par
Description:\par
\par
This function is used to retrieve the ascii code of a specified character,\par
when you know its scancode. The problem is that for each scancode there can\par
be one or two associated characters... For example, the "A" character is\par
associated to the scancode number 30, but also "a" is associated to 30;\par
DirectQB has two internal tables holding all the possible combinations, so\par
you must specify in which table to search for specified character. That's the\par
purpose of the ShiftFlag parameter: if true, in our example you'll get an "A",\par
otherwise an "a".\par
\par
Notes:\par
\par
This function can be called even if the keyboard handler is off.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBbgtri SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBbgtri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL c1, BYVAL x2,\par
                      BYVAL y2, BYVAL c2, BYVAL x3, BYVAL y3, BYVAL c3)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the triangle\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    c1          color of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    c2          color of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x3          x coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y3          y coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    c3          color of the third vertex\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Draws a gouraud-shaded triangle with (x1,y1), (x2,y2) and (x3,y3) as vertex,\par
interpolating specified colors, using the current palette. Resulting colors\par
are finally blended with the background, using the current blender map.\par
DQBbgtri does not support transparency, but it's affected by the clipping box.\par
\par
Notes:\par
\par
Gouraud shading works better when you set a palette with lots of shades of the\par
same color; it is up to you to find the best settings for your needs. Remember\par
also to set an appropriate blender map to obtain best results; see also\par
DQBtri, DQBbtri, DQBttri\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBbox SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBbox (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,\par
                    BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the box\par
\lang1042\f1\u-1806?\lang1033\f0    x1          Upper left corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y1          Upper left corner y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    x2          Lower right corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Lower right corner y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Drawing color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Draws an empty box on the given layer, with (x1,y1) and (x2,y2) as the upper\par
left and lower right corners, with Col color.\par
\par
Notes:\par
\par
This function is not affected by the clipping box, and no range checks are\par
done, so pay attention. In addition, remember that it must be x1<x2 and y1<y2.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Draws a box on the screen\par
DQBbox VIDEO, 0, 0, 319, 199, 15\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends the program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBboxf SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBboxf (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,\par
                     BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the box\par
\lang1042\f1\u-1806?\lang1033\f0    x1          Upper left corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y1          Upper left corner y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    x2          Lower right corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Lower right corner y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Drawing color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Same as DQBbox, but draws a full box filled with Col color.\par
\par
Notes:\par
\par
See DQBbox.\par
\par
\par
Example:\par
\par
See DQBbox example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBbPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBbPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                     BYVAL SpriteOff, BYVAL BMap)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the sprite data; use VARPTR\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Blender map to be used\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
DQBbPut draws a sprite blending its colors with the background; the way the\par
colors are blended depends on the specified blender map. If the bmap has not\par
been created by calling DQBcreateBMap, this function does nothing. There are\par
virtually unlimited special color effects allowed by using the blender map\par
system: by setting up an appropriate bmap for your palette, you can obtain\par
a translucency effect for example.\par
\par
Notes:\par
\par
DQBbPut is affected by the clipping box, so pixels outside this box will not\par
be drawn; transparency is also supported. See also DQBcreateBMap, DQBsetBMap,\par
DQBgetBMap, DQBloadBMap, DQBsaveBMap, DQBput, DQBfPut, DQBsPut and DQBrPut.\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' Use integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE: 'DIRECTQB.BI'\par
\par
' Let's initialize the library\par
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Releases 256 bytes from the far heap to allow DQBcreateBMap to allocate\par
' conventional memory for the blender map; we're going to map one color only,\par
' so we need 1*256=256 bytes to create the blender map\par
dummy& = SETMEM(-256)\par
\par
' Let's build blender map 1, mapping color 40 only\par
IF DQBcreateBMap(1, 40, 40) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Here we set our only color combination on bmap number 1: if a pixel of\par
' color 40 (bright red) is drawn over another of color 32 (bright blue), the\par
' pixel is drawn with color 13 (bright purple)\par
DQBsetBMap 1, 40, 32, 13\par
\par
' Let's dimension our two sprites using DQBsize\par
size = DQBsize(0, 0, 63, 7)\par
DIM Sprite(size)\par
\par
DQBclearLayer 1\par
DQBprint 1, "DirectQB", 0, 0, 32\par
DQBprint 1, "Power!", 0, 8, 40\par
\par
' Get our sprites\par
DQBget 1, 0, 0, 63, 7, VARSEG(Sprite(0)), VARPTR(Sprite(0))\par
DQBget 1, 0, 8, 63, 15, VARSEG(Sprite(0)), (VARPTR(Sprite(0)) + size)\par
\par
DQBinitVGA\par
\par
' Let's begin the demo\par
FOR x = -64 TO 320\par
  ' Clean our hidden layer\par
  DQBclearLayer 1\par
\par
  ' Draws our sprites on layer 1\par
  DQBput 1, x, 96, VARSEG(Sprite(0)), VARPTR(Sprite(0))\par
  DQBbPut 1, (256 - x), 96, VARSEG(Sprite(0)), (VARPTR(Sprite(0)) + size), 1\par
\par
  ' Copies layer 1 on the screen\par
  DQBwait 3\par
  DQBcopyLayer 1, VIDEO\par
NEXT x\par
\par
' Ends program\par
DQBclose\par
dummy& = SETMEM(256)\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBbtri SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBbtri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,\par
                     BYVAL x3, BYVAL y3, BYVAL Col, BYVAL BMap)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the triangle\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x3          x coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y3          y coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    Col         color\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Blender map to be used\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Draws a triangle with (x1,y1), (x2,y2) and (x3,y3) as vertex, and fills it\par
by blending specified color with the background, using the specified blender\par
map. This function does not support transparency, but it's affected by the\par
clipping box.\par
\par
Notes:\par
\par
See also DQBtri, DQBgtri, DQBttri\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBbttri SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBbttri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,\par
                      BYVAL x3, BYVAL y3, BYVAL u1, BYVAL v1, BYVAL u2,\par
                      BYVAL v2, BYVAL u3, BYVAL v3, BYVAL TextureSeg,\par
                      BYVAL TextureOff, BYVAL BMap)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the triangle\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x3          x coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y3          y coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    u1          x coordinate of first vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    v1          y coordinate of first vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    u1          x coordinate of second vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    v1          y coordinate of second vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    u1          x coordinate of third vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    v1          y coordinate of third vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    TextureSeg  Array segment holding the texture (use VARSEG)\par
\lang1042\f1\u-1806?\lang1033\f0    TextureOff  Array offset holding the texture (use VARPTR)\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Blender map to be used\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Draws a texture-mapped triangle with (x1,y1), (x2,y2) and (x3,y3) as vertexes.\par
This function works exactly like DQBttri, but colors are blended with the\par
background by using the specified blender map.\par
\par
Notes:\par
\par
See also DQBttri, DQBsetTextureSize, DQBtri, DQBbtri, DQBgtri\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBchDir FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBchDir (NewDir AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    NewDir      New directory\par
\par
Returns:\par
\par
0 if the operation is successful, otherwise -1\par
\par
\par
Description:\par
\par
This function changes the current directory to the new specified one; you can\par
also use Windows long directory names.\par
\par
Notes:\par
\par
The main difference between the standard QB statement CHDIR is that this\par
function works also with Windows long filenames, while the first doesn't.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBclearLayer SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBclearLayer (BYVAL Layer)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer to clear\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Clears the contents of a given layer: all the pixels are set to color 0. This\par
function is automatically called for all the allocated layers when calling\par
DQBinit.\par
\par
Notes:\par
\par
None\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
PRINT "Press a key to clear the screen!"\par
WHILE INKEY$="":WEND\par
\par
' Clears the screen\par
DQBclearLayer VIDEO\par
\par
' Ends the program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBclose SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBclose ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This function deallocates the EMS memory used by the layers initialized by\par
DQBinit, turns off the keyboard interrupt handler and the sound engine if\par
they were on; it also deallocates the blender maps if they were created, and\par
does other closing stuff you may have forgot.\par
DQBclose must always be called before ending your programs, otherwise\par
allocated EMS memory will be lost, and you'll have to reboot your computer to\par
free it.\par
\par
Notes:\par
\par
If already in graphics mode, this function also automatically switches the\par
screen to plain text mode, so you don't have to worry about calling\par
DQBinitText before it. See also DQBinit.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBcloseDataFile SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBcloseDataFile ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Close opened datafile; if no datafile was opened, this function does nothing.\par
\par
Notes:\par
\par
You cannot have more than an opened datafile at the same time, so this\par
function may be useful when you have your data stored in different datafiles.\par
This function is automatically called by DQBclose; see also DQBopenDataFile.\par
\par
\par
Example:\par
\par
See DQBopenDataFile example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBcloseFLI SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBcloseFLI ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Closes a FLI file that was previously opened with the DQBopenFLI function.\par
You must close a FLI file with this function before attempting to open another\par
one, otherwise you'll get an error, as DirectQB can handle only one opened\par
FLI animation at a time. If no FLIs were opened, this function does nothing.\par
\par
Notes:\par
\par
This function is meant to be used only in conjunction with DQBopenFLI and\par
DQBplayFLIstep. If you're going to play a whole FLI animation as is by calling\par
DQBplayFLI, there's no need to call also this function when the animation\par
ends. DQBclose automatically calls this function.\par
\par
\par
Example:\par
\par
See DQBplayFLIstep example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBcollide FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBcollide (BYVAL x1, BYVAL y1, BYVAL Seg1, BYVAL Off1, BYVAL x2,\par
                        BYVAL y2, BYVAL Seg2, BYVAL Off2)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x position of first sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y position of first sprite\par
\lang1042\f1\u-1806?\lang1033\f0    Seg1        Segment of first sprite array (use VARSEG)\par
\lang1042\f1\u-1806?\lang1033\f0    Off1        Offset of first sprite array (use VARPTR)\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x position of second sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y position of second sprite\par
\lang1042\f1\u-1806?\lang1033\f0    Seg2        Segment of second sprite array (use VARSEG)\par
\lang1042\f1\u-1806?\lang1033\f0    Off2        Offset of second sprite array (use VARPTR)\par
\par
Returns:\par
\par
True if the sprites collide, otherwise false\par
\par
\par
Description:\par
\par
Given two sprites, this function tests for them to collide, using current\par
check method. There are two collision detection methods available: bounding\par
box check and pixel-perfect check. Needless to say, the first is the fastest,\par
but the other gives you a perfect collision precision.\par
\par
Notes:\par
\par
By default, the collision detection method is the bounding box check; you can\par
change this at any time by calling DQBsetCollideMethod.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBcollideOnLayer FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBcollideOnLayer (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                               BYVAL SpriteOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to test for collision(s)\par
\lang1042\f1\u-1806?\lang1033\f0    x           x position of sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           y position of sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of sprite array (use VARSEG)\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of sprite array (use VARPTR)\par
\par
Returns:\par
\par
Pixel color of first colliding object, 0 on no collisions\par
\par
\par
Description:\par
\par
This function introduces the concept of "collisions layer": by using it, you\par
can achieve fast collision detections between several sprites, in an easy way.\par
By specifying a layer, and a sprite position and data, DQBcollideOnLayer\par
returns the color of the first non-trasparent pixel on the layer, that\par
actually collides with the specified sprite. If no collision is detected, 0\par
is returned.\par
\par
Notes:\par
\par
Sprite position can be inside as well as outside layer space (i.e. clipping\par
is supported); It is suggested that you use DQBhPut to draw all your active\par
sprites on the collision layer, so you can easily check for collisions using\par
this function.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBcopyBlendLayer SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBcopyBlendLayer (BYVAL SourceLayer, BYVAL DestLayer, BYVAL BMap)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    SourceLayer   Source layer to copy data from\par
\lang1042\f1\u-1806?\lang1033\f0    DestLayer     Destination layer where to copy data\par
\lang1042\f1\u-1806?\lang1033\f0    BMap          Blender map to be used\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Copies the contents of SourceLayer and blends them into DestLayer, using\par
specified blender map.\par
\par
Notes:\par
\par
See also DQBcopyLayer, as this function works almost the same way\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBcopyHitLayer SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBcopyHitLayer (BYVAL SourceLayer, BYVAL DestLayer, BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    SourceLayer   Source layer to copy data from\par
\lang1042\f1\u-1806?\lang1033\f0    DestLayer     Destination layer where to copy data\par
\lang1042\f1\u-1806?\lang1033\f0    Col           Filling color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Works exactly like DQBcopyLayer, except for the fact than all the non-0 pixels\par
of the source layer are drawn onto the destination layer with the same color\par
specified with the "Col" parameter.\par
\par
Notes:\par
\par
Useful to create collision layers, to be used in conjunction with the\par
DQBcollideOnLayer function.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBcopyLayer SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBcopyLayer (BYVAL SourceLayer, BYVAL DestLayer)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    SourceLayer   Source layer to copy data from\par
\lang1042\f1\u-1806?\lang1033\f0    DestLayer     Destination layer where to copy data\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Copies the contents of SourceLayer into DestLayer. All the data previously\par
into DestLayer will be lost. This function can be used to create double\par
buffered animations; just draw every sprite onto a layer on EMS, and then use\par
DQBcopyLayer to copy its contents to the screen.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with one extra layer and no sounds\par
IF DQBinit(1, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Draws a box on the hidden layer\par
DQBbox 1, 0, 0, 319, 199, 15\par
\par
' Copies the hidden layer on the screen\par
DQBcopyLayer 1, VIDEO\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBcopyTransLayer SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBcopyTransLayer (BYVAL SourceLayer, BYVAL DestLayer)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    SourceLayer   Source layer to copy data from\par
\lang1042\f1\u-1806?\lang1033\f0    DestLayer     Destination layer where to copy data\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This function is similar to DQBcopyLayer, but the pixels with color 0 of the\par
source layer are skipped and not copied onto the destination layer; this\par
allows transparent layer copy. With some practice, it is possible to obtain\par
a parallax scrolling effect using this function with DQBscroll.\par
\par
Notes:\par
\par
Needless to say, DQBcopyTransLayer is slower than DQBcopyLayer, be warned.\par
\par
\par
Example:\par
\par
See DQBcopyLayer example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBcreateBMap FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBcreateBMap (BYVAL BMap, BYVAL FirstCol, BYVAL LastCol)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    BMap          Code number of the blender map to create\par
\lang1042\f1\u-1806?\lang1033\f0    FirstCol      First foreground color to map\par
\lang1042\f1\u-1806?\lang1033\f0    LastCol       Last foreground color to map\par
\par
Returns:\par
\par
An INTEGER value holding the operation result:\par
\par
>   0     Blender map successfully created and initialized\par
>   1     Not enough free conventional memory\par
>   2     Blender map already created\par
\par
\par
Description:\par
\par
This function attempts to create a blender map in *conventional* memory; this\par
requires as much memory as much foreground colors you map. A blender map is a\par
table with all the possible color combinations between the specified\par
foreground colors and the 256 background colors; so this is the formula to\par
obtain the amount of memory needed to create a bmap:\par
\par
                        (LastCol - FirstCol + 1) * 256\par
\par
The fore color is the color of each pixel of your sprite, and the back color\par
is the one of each pixel of the background layer where you're drawing. Suppose\par
you have a palette with color 1 as bright red, color 2 as bright green, and\par
color 3 as bright purple. Well, you could call DQBsetBMap 7,1,2,3: this way\par
every time you use DQBbPut referring to bmap number 7 to draw a sprite with\par
some pixels of color 1, and the background is filled with color 2, you'll see\par
a cyan sprite (i.e. drawn with color 3)...\par
It's a hard thing to explain, but once you've understood it, you'll also\par
understand the system offers virtually any special effect, depending on your\par
palette and, of course, on the blender map you set.\par
\par
Notes:\par
\par
So you have to set your blender map on your needs: as it's often a slow\par
process, there're the DQBsaveBMap and DQBloadBMap functions that help you.\par
It is also suggested that you use DQBfindCol to create your blender map\par
independently from the current palette. Keep also in mind that any blending\par
function will not work unless the blender map has not been created by calling\par
DQBcreateBMap, and remember that to gain more free base memory you should\par
always call the QB function SETMEM before calling it; another important thing\par
to remember is that a bmap can have up to 255 foreground colors mapped: do\par
not try to create a bmap of 256 elements, as you may end up with unpredictable\par
results. Here I suggest you to leave color 0 unmapped, as it should always be\par
used for transparencies only. See also DQBsetBMap, DQBgetBMap, DQBloadBMap,\par
DQBsaveBMap, DQBbPut, DQBfilterBox.\par
\par
\par
Example:\par
\par
See DQBbPut example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBdir$ FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBdir$ (Mask AS STRING, Attrib AS INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Mask          Mask for file(s) to search for\par
\lang1042\f1\u-1806?\lang1033\f0    Attrib        Attributes of the file(s) to search for\par
\par
Returns:\par
\par
A STRING holding the filename of the next file found\par
\par
\par
Description:\par
\par
DQBdir scans the directory for the files matching specified mask; the mask\par
can include full path and wildcards, and you can also use Windows long\par
filenames. If no files are found, the function returns a null string. The\par
first time DQBdir is called with a mask, it searches for the first file\par
matching it; if a file is found, then you can continue to scan the directory\par
by calling this function again, but by passing a null string as mask. Repeat\par
this process until you get a null string, and you'll obtain a full directory\par
scan. The attrib parameter specifies which kind of files to search for: there\par
are constants made up for you, which you can also sum to search for a larger\par
variety of files (for example, to search simultaneously for normal archive\par
files and directories), so just take a look at appendix A for them.\par
\par
Notes:\par
\par
A hint: you can determine if a file exists by simply checking if DQBdir$ of\par
that file as mask, with ATTRIB.A as attribute, gives a null string or the\par
file name itself...\par
See also DQBdrive$, DQBpath$, DQBnumDrives, DQBsetDrive, DQBchDir\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
CLS\par
\par
' Prints available drives\par
PRINT "Available drives: ";\par
FOR i = 1 TO DQBnumDrives\par
  PRINT "[" + CHR$(64 + i) + "] ";\par
NEXT i\par
PRINT\par
\par
' Prints volume label\par
PRINT "Current volume label is " + DQBdir$("*.*",ATTRIB.L)\par
\par
' Prints current drive and directory\par
PRINT "Directory of " + DQBdrive$ + ":\\" + DQBpath$\par
\par
' Let's search for normal archive ".BAS" files\par
File$ = DQBdir$("*.BAS", ATTRIB.A)\par
IF File$ = "" THEN\par
  ' No files matching\par
  PRINT "No .BAS files found!"\par
ELSE\par
  ' A first file was found! Let's print it\par
  PRINT File$\par
\par
  ' Now we search for the next files... if any\par
  DO\par
    ' This second time we don't need the mask nor the attributes\par
    File$ = DQBdir$("",0)\par
\par
    ' If no more files are found, then exit the loop\par
    IF File$ = "" THEN EXIT DO\par
\par
    ' Prints our next file\par
    PRINT File$\par
  LOOP\par
END IF\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBdrive$ FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBdrive$ ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
The drive letter character\par
\par
\par
Description:\par
\par
This function simply returns a string of 1 character holding the current\par
drive letter.\par
\par
Notes:\par
\par
See also DQBsetDrive, DQBnumDrives, DQBchDir, DQBdir$, DQBpath$\par
\par
\par
Example:\par
\par
See DQBdir$ example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBellipse SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBellipse (BYVAL Layer, BYVAL x, BYVAL y, BYVAL rx, BYVAL ry,\par
                        BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer         Source layer to copy data from\par
\lang1042\f1\u-1806?\lang1033\f0    x             x coordinate of the center of your ellipse\par
\lang1042\f1\u-1806?\lang1033\f0    y             y coordinate of the center of your ellipse\par
\lang1042\f1\u-1806?\lang1033\f0    rx            Horizontal radius in pixels\par
\lang1042\f1\u-1806?\lang1033\f0    ry            Vertical radius in pixels\par
\lang1042\f1\u-1806?\lang1033\f0    Col           Ellipse color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This function is useful to draw ellipses (and, needless to say, a circle is\par
a particular ellipse with equal radiuses); the radiuses can range from 0 up\par
to 256.\par
\par
Notes:\par
\par
Also DQBellipse is affected by the clipping box\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with one extra layer and no sounds nor EMS\par
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
FOR i = 10 TO 90 STEP 10\par
  ' Draws our ellipses\par
  DQBellipse VIDEO, 160, 100, 90, i, 40\par
  DQBellipse VIDEO, 160, 100, i, 90, 40\par
NEXT i\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBerror$ FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBerror$ ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
A STRING holding the last error message\par
\par
\par
Description:\par
\par
With this DQBerror$, you do not need to check for every unsuccessfull result\par
of your DQB function calls anymore: when something goes wrong, DQBerror$\par
automatically holds a short error message that explains what went wrong.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with one extra layer and one sound, but no EMS\par
IF DQBinit(1, 1, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' If we get here, no errors have occured\par
PRINT "DirectQB successfully initialized!"\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBfadeIn SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBfadeIn (Pal AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Pal         A string of 768 characters holding the palette to fade into\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Fades the current palette into the given one; current palette may be\par
completely different from the target one. The Pal string can be obtained by\par
calling the DQBgetPal or the DQBloadImage functions, or it can be set\par
manually; just keep in mind that there're three bytes for each color,\par
representing the red, green and blue components of them, in the range 0-63.\par
\par
Notes:\par
\par
See also DQBfadeTo, DQBgetPal, DQBsetPal, DQBpalOff, DQBgetCol, DQBsetCol\par
\par
\par
Example:\par
\par
See DQBfadeTo example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBfadeStepIn SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBfadeStepIn (Pal AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Pal         A string of 768 characters holding the palette to fade into\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Works exactly like DQBfadeIn, but this will only fade all the colors by a\par
single step. To be sure of fading all your colors to the new palette, you\par
should call this function 64 times repeatedly. DQBfadeStepIn can be useful to\par
move your stuff around while fading.\par
\par
Notes:\par
\par
See also DQBfadeIn\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBfadeStepTo SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBfadeStepTo (BYVAL Red, BYVAL Green, BYVAL Blue)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Red         Red hue to fade colors into\par
\lang1042\f1\u-1806?\lang1033\f0    Green       Green hue to fade colors into\par
\lang1042\f1\u-1806?\lang1033\f0    Blue        Blue hue to fade colors into\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Works exactly like DQBfadeTo, but this function will only fade all the colors\par
by a single step. As with DQBfadeStepIn, to be sure to fade all your palette,\par
you should call this function 64 times. DQBfadeStepTo can be useful to move\par
your stuff around while fading.\par
\par
Notes:\par
\par
See also DQBfadeTo\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBfadeTo SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBfadeTo (BYVAL Red, BYVAL Green, BYVAL Blue)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Red         Red hue to fade colors into\par
\lang1042\f1\u-1806?\lang1033\f0    Green       Green hue to fade colors into\par
\lang1042\f1\u-1806?\lang1033\f0    Blue        Blue hue to fade colors into\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Fades all the colors in current palette to the specified red, green and blue\par
hues. To fade a palette to black, just call this function with 0,0,0 as\par
parameters; it's quite powerful, as it can fades any palette to any specified\par
color.\par
\par
Notes:\par
\par
See also DQBfadeIn, DQBgetPal, DQBsetPal, DQBpalOff, DQBgetCol, DQBsetCol\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
DIM Pal AS STRING * 768\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Stores the default palette into Pal\par
DQBgetPal Pal\par
\par
' Turns all the colors to black\par
DQBpalOff\par
\par
' Draws randomly 500 pixels on the screen\par
FOR i = 1 TO 500\par
    RANDOMIZE TIMER\par
    DQBpset VIDEO, (RND*320), (RND*200), (RND*256)\par
NEXT i\par
\par
' Fades the palette into the original one\par
DQBfadeIn Pal\par
\par
' Fades the palette to white\par
DQBfadeTo 63, 63, 63\par
\par
' and then to black\par
DQBfadeTo 0,0,0\par
\par
' Restores the original palette\par
DQBsetPal Pal\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBfilterBox SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBfilterBox (BYVAL Layer, BYVAL x1, BYVAL y2, BYVAL x2, BYVAL y2,\par
                          BYVAL Col, BYVAL BMap)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the filter box\par
\lang1042\f1\u-1806?\lang1033\f0    x1          Upper left corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y1          Upper left corner y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    x2          Lower right corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Lower right corner y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Filter color\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Blender map to be used\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
DQBfilterBox draws a full box blending specified color with the background,\par
using the given blender map; if the blender map has not been created, this\par
function will not draw the box.\par
\par
Notes:\par
\par
The filter color acts as the fore color; it's up to you to set an appropriate\par
blender map. Remember also that it must be x2>=x1 and y2>=y1. See also\par
DQBcreateBMap, DQBloadBMap, DQBsaveBMap, DQBsetBMap, DQBgetBMap and DQBbPut.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBfindCol FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBfindCol (BYVAL Red, BYVAL Green, BYVAL Blue)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Red         Red hue of the color to find\par
\lang1042\f1\u-1806?\lang1033\f0    Green       Green hue of the color to find\par
\lang1042\f1\u-1806?\lang1033\f0    Blue        Blue hue of the color to find\par
\par
Returns:\par
\par
An INTEGER value ranging 0-255, holding the index of the color found\par
\par
\par
Description:\par
\par
DQBfindCol searches the current palette for the color that best fits with the\par
specified red, green and blue hues. It can be really useful to create a\par
blender map in conjunction with the DQBsetBMap routine.\par
\par
Notes:\par
\par
This function may return bad results, depending on the current palette and\par
the specified hues, so use it with caution. As it scans the palette, you'll\par
see the screen flickering a little during each call to this function; to\par
avoid this, you can use the DQBfindPalCol, that allows to search for a color\par
into any specified palette.\par
\par
\par
Example:\par
\par
none\par
\par
-----------------------------------------------------------------------------\par
DQBfindPalCol FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBfindPalCol (Pal AS STRING, Red AS INTEGER,\par
                                Green AS INTEGER, Blue AS INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Pal         Palette to scan\par
\lang1042\f1\u-1806?\lang1033\f0    Red         Red hue of the color to find\par
\lang1042\f1\u-1806?\lang1033\f0    Green       Green hue of the color to find\par
\lang1042\f1\u-1806?\lang1033\f0    Blue        Blue hue of the color to find\par
\par
Returns:\par
\par
An INTEGER value ranging 0-255, holding the index of the color found\par
\par
\par
Description:\par
\par
This function works exactly like DQBfindCol, except for the fact that this one\par
searches for a color into a specified palette, not necessarly on the current\par
one. This also avoids the bad looking flickering of the DQBfindCol function.\par
The palette should be get by the DQBgetPal, DQBloadLayer or similar routines\par
that use the standard DirectQB palette format (see appendix C for details).\par
\par
Notes:\par
\par
See also DQBfindCol\par
\par
\par
Example:\par
\par
none\par
\par
-----------------------------------------------------------------------------\par
DQBfpu SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBfpu\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Speeds up Qbasic's math routines, by minimizing the wait state length during\par
math routines.\par
\par
Notes:\par
\par
a 486 CPU is needed to use this routine, best if used during initialization.\par
\par
\par
Example:\par
\par
'$INCLUDE: 'DIRECTQB.BI'\par
IF DQBinit(0,0,0) then DQBclose: PRINT DQBerror$\par
DQBfpu\par
'You're Code here\par
DQBclose\par
END\par
\par
\par
-----------------------------------------------------------------------------\par
DQBfPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBfPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                     BYVAL SpriteOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the sprite data; use VARPTR\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Like DQBput, DQBfPut draws a sprite on specified layer, but using a faster\par
algorithm. This function does not allow clipping nor transparency, and works\par
better with big sprites with a width which is a multiple of 4.\par
\par
Notes:\par
\par
See DQBput, DQBsPut, DQBrPut and DQBbPut\par
\par
\par
Example:\par
\par
See DQBput example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBframeReady FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBframeReady ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
True if enough time has passed to synchronize graphics, otherwise false\par
\par
\par
Description:\par
\par
DQBframeReady is to be used in conjunction with DQBsetFrameRate to synchronize\par
your graphics with a specified framerate. Once you set the FPS rate with\par
DQBsetFrameRate, you should wait before displaying each frame, until this\par
function returns true.\par
\par
Notes:\par
\par
See DQBsetFrameRate\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBfttri SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBfttri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,\par
                      BYVAL x3, BYVAL y3, BYVAL u1, BYVAL v1, BYVAL u2,\par
                      BYVAL v2, BYVAL u3, BYVAL v3, BYVAL TextureSeg,\par
                      BYVAL TextureOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the triangle\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x3          x coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y3          y coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    u1          x coordinate of first vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    v1          y coordinate of first vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    u2          x coordinate of second vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    v2          y coordinate of second vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    u3          x coordinate of third vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    v3          y coordinate of third vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    TextureSeg  Array segment holding the texture (use VARSEG)\par
\lang1042\f1\u-1806?\lang1033\f0    TextureOff  Array offset holding the texture (use VARPTR)\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Works exactly like normal DQBttri, but applies bilinear filtering during the\par
texturing process. This function is slower than DQBttri, but it draws better\par
looking triangles; anyway you need a gradient palette in order to achieve\par
good results.\par
\par
Notes:\par
\par
As this function has been coded thinking about speed, it isn't too accurate\par
with its calculations; this means that to be sure your triangle will be drawn\par
correctly, you should use a gradient palette set in the way that at least 4\par
or 5 colors are NOT used by your texture before and after its colors range.\par
I mean that if your texture uses only color 5 to 100, you also need to set\par
colors 0-4 and 101-105; this way you'll avoid boring problems... See also\par
DQBsetTextureSize, DQBtri, DQBbtri, DQBgtri, DQBttri\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
DIM texture(2049)\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Creates a red gradient palette\par
FOR i = 0 TO 63\par
  DQBsetCol i, i, 0, 0\par
  DQBsetCol 64 + i, 63, i, i\par
NEXT i\par
\par
' Creates a texture filled with random red pixels\par
FOR x = 0 TO 63\par
  FOR y = 0 TO 63\par
    DQBpset VIDEO, x, y, 5 + (RND * 118)\par
  NEXT y\par
NEXT x\par
DQBbox VIDEO, 0, 0, 63, 63, 127\par
DQBline VIDEO, 63, 0, 0, 63, 127\par
\par
' Gets the texture\par
DQBget VIDEO, 0, 0, 63, 63, VARSEG(texture(0)), VARPTR(texture(0))\par
\par
' Clears the screen\par
DQBclearLayer VIDEO\par
\par
' Draws 500 random triangles\par
FOR i = 1 TO 500\par
  RANDOMIZE TIMER\par
  DQBfttri VIDEO, RND * 320, RND * 200, RND * 320, RND * 200, RND * 320, RND * 200, 0, 0, 63, 0, 0, 63, VARSEG(texture(0)), VARPTR(texture(0))\par
NEXT i\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
END\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBget SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBget (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,\par
                    BYVAL SpriteSeg, BYVAL SpriteOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to get the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x1          Upper left corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y1          Upper left corner y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    x2          Lower right corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Lower right corner y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array where to store the sprite; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array where to store the sprite; use VARPTR\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Gets a sprite from the given layer in the box (x1,y1)-(x2,y2) and places the\par
data into specified array. Array must be dimensioned as (((Width*Height)*2)+4)\par
INTEGERs; you can use the DQBsize function and divide the result by 2 to\par
retrieve the size of your array without worring about this formula. Sprites\par
get with DQBget can be then used by DQBput to create animations.\par
\par
Notes:\par
\par
DQBget is not affected by the clipping box. Also, it must be x1<x2 and y1<y2.\par
This routine is optimized if your sprite width is a multiple of 4 or 2.\par
Several sprites can be stored into the same array; just pass the sprite with\par
a different index. In addition, the format of DQBget and DQBput is compatible\par
with the one of GET and PUT, so you can use them with the same sprite arrays.\par
See also DQBfPut, DQBsPut, DQBrPut and DQBbPut\par
\par
Example:\par
\par
See DQBput example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBgetBMap FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBgetBMap (BYVAL BMap, BYVAL ForeCol, BYVAL BackCol)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Blender map to get color info from\par
\lang1042\f1\u-1806?\lang1033\f0    ForeCol     Foreground color\par
\lang1042\f1\u-1806?\lang1033\f0    BackCol     Background color\par
\par
Returns:\par
\par
An INTEGER value holding the color set for the specified combination in the\par
specified blender map\par
\par
\par
Description:\par
\par
Returns the color set on the specified blender map for the color combination\par
given by the specified foreground and background colors. If the foreground\par
color is not mapped into the blender map, this function returns unpredictable\par
results, so pay attention.\par
\par
Notes:\par
\par
See also DQBcreateBMap and DQBsetBMap\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBgetCol SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBgetCol (BYVAL Col, Red, Green, Blue)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Color index to retrieve data from\par
\lang1042\f1\u-1806?\lang1033\f0    Red         INTEGER variable where to store the red hue\par
\lang1042\f1\u-1806?\lang1033\f0    Green       INTEGER variable where to store the green hue\par
\lang1042\f1\u-1806?\lang1033\f0    Blue        INTEGER variable where to store the blue hue\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Gets the red, green and blue hues of the given color and stores them into the\par
Red, Green and Blue INTEGER variables. Hues ranges from 0-63.\par
\par
Notes:\par
\par
See also DQBsetCol\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
DIM r, g, b\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Gets the hues for color 2 (dark green in default BIOS palette)\par
DQBgetCol 2, r, g, b\par
\par
PRINT "Color 2 hues:"\par
PRINT "Red:", r\par
PRINT "Green:", g\par
PRINT "Blue:", b\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBgetPal SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBgetPal (Pal AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Pal         String of 768 character where to store the palette\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Gets the current palette and stores it into the Pal string. Such a palette\par
can be then used by the DQBsetPal, DQBfadeIn and DQBsaveLayer functions.\par
\par
Notes:\par
\par
See appendix A to know how the palette is stored into the string\par
\par
\par
Example:\par
\par
See DQBfadeTo example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBgline SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBgetPal (Layer AS INTEGER, x1 AS INTEGER, y1 AS INTEGER, x2 AS\par
                       INTEGER, y2 AS INTEGER, Col1 AS INTEGER, Col2 AS\par
                       INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer to draw the line onto\par
\lang1042\f1\u-1806?\lang1033\f0    x1          First endpoint x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y1          First endpoint y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    x2          Second endpoint x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Second endpoint y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    Col1        First endpoint color\par
\lang1042\f1\u-1806?\lang1033\f0    Col2        Second endpoint color\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Like normal DQBline, this function draws a line onto the specified layer, but\par
interpolating colors between the two indexes specified at the endpoints; it\par
is recommended that you call this function only after setting up a proper\par
gradient palette.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBgtri SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBgtri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL c1, BYVAL x2,\par
                     BYVAL y2, BYVAL c2, BYVAL x3, BYVAL y3, BYVAL c3)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the triangle\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    c1          color of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    c2          color of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x3          x coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y3          y coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    c3          color of the third vertex\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Draws a gouraud-shaded triangle with (x1,y1), (x2,y2) and (x3,y3) as vertex,\par
interpolating specified colors, using the current palette. DQBgtri does not\par
support transparency, but it's affected by the clipping box.\par
\par
Notes:\par
\par
Gouraud shading works better when you set a palette with lots of shades of the\par
same color; it is up to you to find the best settings for your needs. See also\par
DQBtri, DQBbtri, DQBttri\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Sets up the palette with shades of red\par
FOR i = 0 TO 63\par
  DQBsetCol i, i, 0, 0\par
  DQBsetCol 64 + i, 63, i, i\par
NEXT i\par
\par
' Draws 500 gouraud-shaded triangles; uses only the first 128 colors we set\par
FOR i = 1 TO 500\par
  DQBgtri VIDEO, (RND * 320), (RND * 200), (RND * 128), (RND * 320), (RND * 200), (RND * 128), (RND * 320), (RND * 200), (RND * 128)\par
NEXT i\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBhPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBhPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                     BYVAL SpriteOff, BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the sprite data; use VARPTR\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Drawing color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This function works exactly like normal DQBput, but it draws the whole sprite\par
using the same specified color, despite its original colors. It supports\par
clipping, but doesn't allow solid put mode; color 0 is always treated as\par
the transparent color.\par
\par
Notes:\par
\par
See also DQBput\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBid$ FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBid$ ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Returns a small string that contains the library version and my name, in case\par
you want to display them somewhere in your credits section.\par
\par
Notes:\par
\par
You can use DQBver to retrive the library version only\par
\par
\par
Example:\par
\par
See DQBver example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBinit FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBinit (BYVAL NumLayers, BYVAL NumSounds, BYVAL MemSize)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    NumLayers   Number of layers to allocate memory for\par
\lang1042\f1\u-1806?\lang1033\f0    NumSounds   Number of sounds to allocate memory for\par
\lang1042\f1\u-1806?\lang1033\f0    MemSize     Kbytes of EMS memory to preserve for custom purposes\par
\par
Returns:\par
\par
An INTEGER value holding the initialization result. It can be:\par
\par
>   0     Initialization successful\par
>   1     386 or better CPU not detected\par
>   2     Unable to find an expanded memory manager\par
>   3     Not enough free EMS memory to allocate specified number of layers\par
>   4     Library has already been initialized\par
\par
\par
Description:\par
\par
The DQBinit function must be called before any of the other library functions.\par
It allocates a specified number of layers, sounds and free memory into EMS,\par
and does other initializations; remember that you can allocate as much layers\par
as you want, and up to 256 sounds, as long as enough free memory is available,\par
otherwise you'll get an error 3 when calling this function; the same goes for\par
the amount of EMS for personal purposes: the limit is the amount of free EMS\par
available on your system.\par
The only thing you need to know is that each layer or sound takes 64KB of EMS.\par
Also, please keep in mind that if you refer to a layer or a sound number that\par
has not been allocated with this procedure, your system will probably crash:\par
I mean that if you allocate 3 layers with DQBinit, you must not refer to layer\par
4. If you get an error 2, please refer to section 1.3 of this manual, that\par
explains how to install EMS on your system.\par
\par
Notes:\par
\par
As DQBinit must be called at the beginning of your program, remember to call\par
DQBclose at its end. Initialized layers are automatically cleared (they're\par
filled with pixel color 0), and the sounds are reset to silence and 0 length.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with four extra layers and no sounds nor EMS\par
Result = DQBinit(4, 0, 0)\par
\par
' Closes DirectQB\par
DQBclose\par
\par
' A smarter way to handle errors would be to use DQBerror$, but for clarity\par
' here we do it this way:\par
SELECT CASE Result\par
CASE 0\par
    PRINT "Initialization successful"\par
CASE 1\par
    PRINT "Error: 386 or better CPU not detected!"\par
CASE 2\par
    PRINT "Error: unable to find an expanded memory manager!"\par
CASE 3\par
    PRINT "Error: not enough free EMS memory!"\par
END SELECT\par
\par
' Ends program\par
END\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBinitText SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBinitText()\par
\par
Calling:\par
\par
none\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Initializes plain 80x25 text mode (mode 03h).\par
\par
Notes:\par
\par
By using this function instead of SCREEN 0, you can obtain smaller executables\par
once you compile your programs. See also DQBinitVGA\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBinitVGA SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBinitVGA()\par
\par
Calling:\par
\par
none\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Initializes 320x200 with 256 colors VGA video mode (mode 013h), and resets\par
the mouse if it was found.\par
\par
Notes:\par
\par
By using this function instead of SCREEN 13, you can obtain smaller executables\par
once you compile your programs. See also DQBinitText\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBinkey$ FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBinkey$ ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
If a key is pressed, it returns its character, otherwise a null string\par
\par
\par
Description:\par
\par
DQBinkey$ works just like the usual INKEY$ QB statement. If any key is being\par
pressed, this function returns its associated character, otherwise it returns\par
a null string.\par
\par
Notes:\par
\par
This function works only while the custom keyboard handler is on, otherwise\par
you'll probably crash your system. In addition, as DQBinkey$ does not get the\par
character from the standard keyboard buffer, you'll loose your character if\par
you do not store it in some variable.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Installs the keyboard handler\par
DQBinstallKeyboard\par
\par
' Let's prompt the user for a question\par
PRINT "Press 'Y' if you like DirectQB, otherwise 'N'"\par
DO\par
  DO: k$ = DQBinkey$: LOOP WHILE k$ = ""\par
  SELECT CASE k$\par
  CASE "Y": PRINT "Thank you!": EXIT DO\par
  CASE "N": PRINT "Too bad!!": EXIT DO\par
LOOP\par
\par
' Waits for the user to press a key\par
DQBwaitKey KEYANY\par
\par
' Removes the keyboard handler\par
DQBremoveKeyboard\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBinstallKeyboard SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBinstallKeyboard ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Installs a custom keyboard interrupt handler that allows you to detect the\par
exact state (pressed or released) of any key at any time. Once activated by\par
calling this function, the standard QB routines like INPUT, INKEY$ or whatever\par
other routine that uses the keyboard as input, will be unavailable. Calling\par
them will probably result into your machine to crash, so pay attention. These\par
standard routines can be called only when the interrupt handler will be\par
uninstalled by calling DQBremoveKeyboard; this last function is automatically\par
called by DQBclose, so usually you don't have to bother about it. When the\par
handler is active, you can know the state of each key by simply calling the\par
DQBkey function.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBkey example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBinstallSB FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBinstallSB (BYVAL VolActive, BYVAL Voices, BYVAL Freq,\par
                               BYVAL BaseAddr, BYVAL IRQ, BYVAL DMA)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    VolActive   True to preserve base memory for the voices volume table\par
\lang1042\f1\u-1806?\lang1033\f0    Voices      Number of voices to mix at real-time\par
\lang1042\f1\u-1806?\lang1033\f0    Freq        Sampling rate\par
\lang1042\f1\u-1806?\lang1033\f0    BaseAddr    Base address of your soundcard\par
\lang1042\f1\u-1806?\lang1033\f0    IRQ         IRQ number setting\par
\lang1042\f1\u-1806?\lang1033\f0    DMA         Low DMA channel to be used\par
\par
Returns:\par
\par
An INTEGER value holding the initialization result. It can be:\par
\par
>   0     Initialization successful\par
>   1     No sounds were allocated by DQBinit\par
>   2     Soundcard not found or DSP failed to reset\par
>   3     Old soundcard not supported\par
>   4     Specified DMA channel is not supported\par
>   5     Autodetection failed as the BLASTER variable is not set\par
>   6     High mixing speed not supported\par
>   7     Not enough memory to create the volume table\par
\par
\par
Description:\par
\par
DQBinstallSB installs a custom IRQ routine and starts the sound engine if all\par
goes ok. If you don't know your sound settings (base address, IRQ or DMA), you\par
can pass the AUTO constant as the missing parameter(s); this will force the\par
function to search the BLASTER environmental variable (if available) for the\par
right setting. The number of voices can range from 1 up to 32, and tells the\par
sound engine how many digital sound channels to mix at real-time; needless to\par
say, on older computers, too many voices will slow down your programs...\par
The sampling rate may range from 4000 Hz up to 23000 Hz. If you specify true\par
as the VolActive parameter, you'll need 16K of base memory, as the function\par
will build an internal volume table, that will allow you to set custom volume\par
settings to each of the initialized voices; if you don't need to play sounds\par
with different volumes at the same time, you don't need this table, so just\par
pass false to this function.\par
\par
Notes:\par
\par
As always, the SETMEM function should be used to free memory from QB, if you\par
need base memory for the volume table. To turn the sound engine off, call\par
DQBremoveSB; this is anyway automatically called for you by DQBclose. See\par
also DQBloadSound, DQBplaySound, DQBstopVoice\par
\par
\par
Example:\par
\par
See DQBplaySound example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBinUse FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBinUse (BYVAL Voice)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Voice       Voice number to retrive the status of\par
\par
Returns:\par
\par
True if a sound is currently being played on specified voice\par
\par
\par
Description:\par
\par
DQBinUse returns true if any sound is currently playing on the specified\par
voice, otherwise false.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBjoyDetected FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBjoyDetected (BYVAL JoyNum)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    JoyNum      Joystick number to detect\par
\par
Returns:\par
\par
True if specified joystick has been detected, otherwise false\par
\par
\par
Description:\par
\par
This function should be called before using the other joystick functions, to\par
detect if a joystick is available. The parameter JoyNum can be 0 for joystick\par
1, 1 for joystick 2 or 2 for 4-button joystick. If you can't remember this,\par
just call this function, as well as the other joystick functions, with the\par
constants JOY1, JOY2 and GAMEPAD defined into the file DIRECTQB.BI, and\par
explained into appendix A.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Finds if joystick 1 is available\par
IF DQBjoyDetected(JOY1) THEN\par
    PRINT "Joystick 1 detected"\par
ELSE\par
    PRINT "Joystick 1 not detected"\par
END IF\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBjoyFire FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBjoyFire (BYVAL JoyNum, BYVAL Button)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    JoyNum      Joystick number to retrieve status of\par
\lang1042\f1\u-1806?\lang1033\f0    Button      Button number to check\par
\par
Returns:\par
\par
True if specified button of specified joystick is pressed, otherwise false\par
\par
\par
Description:\par
\par
This function is used to check if a button of a specified joystick is being\par
pressed. About the parameter JoyNum, please refer to the DQBjoyDetected\par
function. The other parameter, Button, can be 0 for button A, or 1 for button\par
B. If you're handling a 4-buttons joystick, you can also use 2 and 3 for\par
buttons 3 and 4. As for the joystick number, also the buttons have constants\par
named BUTA, BUTB, BUTC and BUTD declared into the file DIRECTQB.BI, and\par
explained into appendix A.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBjoyMove example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBjoyMove FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBjoyMove (BYVAL JoyNum, BYVAL Direction)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    JoyNum      Joystick number to retrieve status of\par
\lang1042\f1\u-1806?\lang1033\f0    Direction   Direction to check, see below\par
\par
Returns:\par
\par
True if the joystick is moved into the given direction, otherwise false\par
\par
\par
Description:\par
\par
Call this function to know where the joystick has been moved. About the JoyNum\par
parameter refer to the DQBjoyDetected function. The Direction parameter is an\par
integer that must be set to: \par
\par
-   0     to check if the joystick has been moved up\par
-   1     to check if the joystick has been moved down\par
-   2     to check if the joystick has been moved left\par
-   3     to check if the joystick has been moved right\par
\par
There are of course four constants for this parameter, named UP, DOWN, LEFT\par
and RIGHT, declared into the file DIRECTQB.BI, and explained into appendix A.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
DIM X, Y, Col\par
\par
' Let's initialize the library with one extra layer and no sounds nor EMS\par
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
IF NOT DQBjoyDetected(JOY1) THEN\par
    PRINT "Joystick 1 not detected, program aborted."\par
    DQBclose\par
    END\par
END IF\par
\par
DQBinitVGA\par
\par
X = 150: Y = 90\par
\par
DO\par
    ' Polls joystick 1\par
    DQBpollJoy JOY1\par
    \par
    ' Checks movements\par
    IF DQBjoyMove(JOY1, UP) THEN Y = Y - 1      ' Joystick 1 up\par
\par
    IF DQBjoyMove(JOY1, DOWN) THEN Y = Y + 1    ' Joystick 1 down\par
\par
    IF DQBjoyMove(JOY1, LEFT) THEN X = X - 1    ' Joystick 1 left\par
\par
    IF DQBjoyMove(JOY1, RIGHT) THEN X = X + 1   ' Joystick 1 right\par
\par
    ' Adjust coordinates\par
    IF X < 0 THEN X = 0\par
    IF X > 299 THEN X = 299\par
    IF Y < 0 THEN Y = 0\par
    IF Y > 179 THEN Y = 179\par
\par
    ' Resets box color to white\par
    Col = 15\par
\par
    ' If button A is pressed, change color to red\par
    IF DQBjoyFire(JOY1, BUTA) THEN Col = 40\par
\par
    ' If button B is pressed, change color to green\par
    IF DQBjoyFire(JOY1, BUTB) THEN Col = 2\par
\par
    ' Clears the contents of layer 1\par
    DQBclearLayer 1\par
\par
    ' Draws the box\par
    DQBboxf 1, X, Y, (X + 19), (Y + 19), Col\par
\par
    ' Waits for vertical retrace 1 time\par
    DQBwait 1\par
\par
    ' Copies out layer to the screen\par
    DQBcopyLayer 1, VIDEO\par
\par
    ' Prints a message\par
    LOCATE 1\par
    PRINT "  Joystick demo - press a key to exit!"\par
\par
LOOP WHILE INKEY$ = ""\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBjoyX FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBjoyX (BYVAL JoyNum)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    JoyNum      Joystick number to x axis position of\par
\par
Returns:\par
\par
An INTEGER value holding the current joystick x axis position\par
\par
\par
Description:\par
\par
This function can be used to retrieve the exact x axis position of specified\par
joystick, relatively to the center position, that is automatically detected\par
at startup, or by calling DQBresetJoy.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBjoyY FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBjoyY (BYVAL JoyNum)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    JoyNum      Joystick number to y axis position of\par
\par
Returns:\par
\par
An INTEGER value holding the current joystick y axis position\par
\par
\par
Description:\par
\par
This function can be used to retrieve the exact y axis position of specified\par
joystick, relatively to the center position, that is automatically detected\par
at startup, or by calling DQBresetJoy.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBkey FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBkey (BYVAL ScanCode)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    ScanCode    Scancode of the key to retrieve status of\par
\par
Returns:\par
\par
True if the key is pressed, otherwise false\par
\par
\par
Description:\par
\par
This function returns useful information only when the custom keyboard\par
interrupt handler has been installed by calling DQBinstallKeyboard. For a\par
complete list of keyboard scancodes, refer to appendix B. There're also a few\par
constants declared into the file DIRECTQB.BI, such as KEYESC, KEYENTER, KEYUP,\par
KEYDOWN, KEYLEFT, KEYRIGHT and others, explained into appendix A.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Let's install the custom keyboard handler\par
DQBinstallKeyboard\par
\par
CLS\par
PRINT "Keyboard demo - press any key to see its scancode. Multiple\par
keypresses are allowed; press ESC to exit."\par
\par
DO\par
    LOCATE 3, 1\par
\par
    ' Scans every possible key\par
    FOR i = 0 TO 127\par
        ' If the key is pressed, prints its scancode\par
        IF DQBkey(i) THEN PRINT "[" + LTRIM$(STR$(i)) + "] ";\par
    NEXT i\par
\par
    ' Clears a portion of the screen\par
    PRINT SPACE$(40)\par
\par
' Loops while the ESC key is not pressed\par
LOOP UNTIL DQBkey(KEYESC)\par
\par
' Uninstalls the keyboard handler (this is not really needed when we're\par
' going to end the program by calling DQBclose)\par
DQBremoveKeyboard\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBlen FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBlen (Text AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Text        Text string to retrieve the length of\par
\par
Returns:\par
\par
An INTEGER holding the length in pixels of the given string, assuming the\par
current font characters length\par
\par
\par
Description:\par
\par
Like LEN, DQBlen returns the length of a specified string, but in pixel units.\par
As DirectQB supports non-fixed sized fonts, this function is useful to\par
retrieve the length of a string in pixels, calculated using the length of\par
the characters of the current font.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
Length = DQBlen("The length of this string is:")\par
DQBprint VIDEO, "The length of this string is:" + STR$(Length) + " pixels", 0, 0, 31\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBline SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBline (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,\par
                     BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the line onto\par
\lang1042\f1\u-1806?\lang1033\f0    x1          First point x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y2          First point y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    x2          Second point x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Second point y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Drawing color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This procedure draws a line from point at (x1,y1) to point at (x2,y2), on the\par
given layer and with specified color. The Bresenham's line algorithm is used.\par
\par
Notes:\par
\par
DQBline is affected by the clipping box; see also DQBgline\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBloadBMap FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBloadBMap (BMap AS INTEGER, FileName AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Number of the blender map to load data into\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    Blender map file name with full extension\par
\par
Returns:\par
\par
An INTEGER value holding the loading results:\par
\par
>   0     Loading successful\par
>   1     Blender map not yet created\par
>   2     Cannot open file, or file does not exist\par
>   3     Bad or unknown file format\par
>   4     Incompatible blender map\par
>   5     General reading error\par
\par
\par
Description:\par
\par
Loads data from a specified binary file into the blender map; the blender map\par
must have been previously created by calling DQBcreateBMap.\par
\par
Notes:\par
\par
The bmap number where to load data onto must be compatible with the bmap\par
saved on the file: this means that the number of mapped foreground colors\par
must be the same for both the bmap stored on the file and the bmap structure\par
where you are about to load it into. See also DQBcreateBMap and DQBsaveBMap\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBloadFont FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBloadFont (FileName AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    Font file with full extension\par
\par
Returns:\par
\par
An INTEGER value holding the loading results:\par
\par
>   0     Loading successful\par
>   1     Cannot open file, or file does not exist\par
>   2     General reading error\par
\par
\par
Description:\par
\par
Loads and sets a font from a specified file. The font file must contain the\par
data in the first 2305 bytes, in the format explained into appendix C.\par
\par
Notes:\par
\par
This function is useful as it doesn't require a QB buffer to hold the data;\par
the disadvantage of using it, is that every time you change the font, the disk\par
is accessed. By using DQBsetFont instead, you can keep your fonts in QB memory\par
and set them as needed.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBloadImage FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBloadImage (Layer AS INTEGER, x AS INTEGER, y AS INTEGER,\par
                               FileName AS STRING, Pal AS STRING, ImgWidth AS\par
                               INTEGER, ImgHeight AS INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to load the image onto\par
\lang1042\f1\u-1806?\lang1033\f0    x           x position where to begin drawing\par
\lang1042\f1\u-1806?\lang1033\f0    y           y position where to begin drawing\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    Image file name with full extension\par
\lang1042\f1\u-1806?\lang1033\f0    Pal         String where the image palette is loaded into\par
\lang1042\f1\u-1806?\lang1033\f0    ImgWidth    Integer variable to store the image width\par
\lang1042\f1\u-1806?\lang1033\f0    ImgHeight   Integer variable to store the image height\par
\par
Returns:\par
\par
An INTEGER value holding the loading results:\par
\par
>   0     Loading successful\par
>   1     Cannot open file, or file does not exist\par
>   2     General reading error\par
>   3     Bad or unknown file format\par
\par
\par
Description:\par
\par
Loads an image into specified layer, at specified coordinates. Images can be\par
of any size, up to 320x200 pixels, but it must have been saved with 256 colors.\par
You can load BMP, PCX or BSAVEd files; the format is automatically detected\par
and it's independent from the file extension. The function returns 0 if the\par
operation is successful, otherwise an error code (see above). When loading a\par
BMP or a PCX image, the palette is stored into the Pal string; current palette\par
is not changed, allowing you to change it only when you want, by calling\par
DQBsetPal or DQBfadeIn, or any way you like. In the case you're loading a BSV\par
image, the function searches for the palette appended at the end of the file;\par
if it finds it, you'll get it stored into the Pal string as well. In all cases,\par
the image width and height will be stored into the ImgWidth and ImgHeight\par
variables.\par
\par
Notes:\par
\par
See appendix C to know the palette string format\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBloadRawSound FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBloadRawSound (Slot AS INTEGER, FileName AS STRING,\par
                                  Offset AS LONG, Length AS INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Slot        Sound slot to load the sound into\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    Sound file name with full extension\par
\lang1042\f1\u-1806?\lang1033\f0    Offset      File position where to begin to load in bytes\par
\lang1042\f1\u-1806?\lang1033\f0    Length      Sound data length in bytes\par
\par
Returns:\par
\par
An INTEGER value holding the loading results:\par
\par
>   0     Loading successful\par
>   1     Cannot open file, or file does not exist\par
>   2     General reading error\par
>   3     Cannot read past the end of file\par
>   4     Specified sound slot does not exist\par
\par
\par
Description:\par
\par
Loads sound data from a specified position on a given file. This function\par
does not check for the data format, and directly stores the sound into the\par
specified slot. DQBloadRawSound can be useful to handle sound data files\par
holding multiple sounds data, as well as when DQBloadSound fails the sound\par
data format check.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBloadSound FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBloadSound (Slot AS INTEGER, FileName AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Slot        Sound slot to load sound into\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    Sample file name with full extension\par
\par
Returns:\par
\par
An INTEGER value holding the loading results:\par
\par
>   0     Loading successful\par
>   1     Cannot open file, or file does not exist\par
>   2     General reading error\par
>   3     Bad or unknown file format\par
>   4     Sound format not yet supported\par
>   5     Sound file exceeds the 64K length limit\par
>   6     Specified sound slot does not exist\par
\par
\par
Description:\par
\par
Loads a sound sample from file and stores it into EMS. The "Slot" parameter\par
identifies the sound effect and is used by the DQBplaySound function.\par
\par
Notes:\par
\par
Only 8-bit mono WAV files are supported for now, so be warned.\par
\par
\par
Example:\par
\par
See DQBplaySound example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBmapLayer FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBmapLayer (BYVAL Layer)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Number of the layer to map\par
\par
Returns:\par
\par
An INTEGER value holding the segment where you can access the layer data\par
\par
\par
Description:\par
\par
This function is useful when you want to have complete control over a\par
specified layer: infact DQBmapLayer returns the segment of the 64K memory\par
window where the layer data is held. If the layer is on EMS, the function\par
returns the EMS pageframe, and it also map it to the specified layer data.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBmouseDetected FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBmouseDetected ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
An INTEGER value holding the mouse initialization result:\par
\par
>   0     Mouse not detected\par
>   -1    Mouse detected and successfully initialized\par
\par
\par
Description:\par
\par
Returns true if a mouse has been detected on your system; you should call this\par
before calling any other mouse routine.\par
\par
Notes:\par
\par
It is recommended that you also call DQBresetMouse just after setting mode\par
13h by calling SCREEN 13, before using any other mouse routine.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with one extra layer and no sounds nor EMS\par
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Checks if a mouse has been detected\par
IF NOT DQBmouseDetected THEN\par
    ' Mouse has not been detected\par
    PRINT "This demo requires a mouse to run!"\par
    DQBclose\par
    END\par
END IF\par
\par
DQBinitVGA\par
\par
' Resets the mouse cursor and range\par
DQBresetMouse\par
\par
' Sets a new mouse range\par
DQBsetMouseRange 6, 6, 314, 148\par
\par
DO\par
    ' Let's clear layer 1\par
    DQBclearLayer 1\par
\par
    DQBbox 1, 5, 5, 315, 149, 32\par
\par
    ' Prints some stats\par
    DQBprint 1, "PRESS ANY KEY TO EXIT DEMO", 0, 170, 40\par
\par
    ' Prepares our info string\par
    Info$ = "Mouse is at" + str$(DQBmouseX) + "," + str$(DQBmouseY)\par
    Info$ = Info$ + " - Buttons: " + str$(DQBmouseLB) + " " + str$(DQBmouseRB)\par
\par
    DQBprint 1, Info$, 0, 180, 40\par
\par
    ' Hides the mouse cursor before drawing to the screen\par
    DQBmouseHide\par
\par
    ' Copies layer 1 onto the screen\par
    DQBcopyLayer 1, VIDEO\par
\par
    ' Shows the cursor again\par
    DQBmouseShow\par
\par
' Loops while no keys are pressed\par
LOOP WHILE INKEY$ = ""\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBmouseHide SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBmouseHide ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Hides the mouse cursor if it was visible. Though the mouse is not visible, it\par
remains active.\par
\par
Notes:\par
\par
See DQBmouseShow\par
\par
\par
Example:\par
\par
See DQBmouseDetected example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBmouseLB FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBmouseLB ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
-1 if the left mouse button is currently pressed, otherwise 0\par
\par
\par
Description:\par
\par
Call this function to know if the left mouse button is pressed or released.\par
It can be called at any time, as the mouse status is automatically checked.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBmouseInit example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBmouseRB FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBmouseRB ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
-1 if the right mouse button is currently pressed, otherwise 0\par
\par
\par
Description:\par
\par
Call this function to know if the right mouse button is pressed or released.\par
It can be called at any time, as the mouse status is automatically checked.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBmouseInit example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBmouseShow SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBmouseShow ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Shows the mouse cursor if it was not visible.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBmouseInit example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBmouseX FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBmouseX ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
An INTEGER value holding the current mouse x coordinate\par
\par
\par
Description:\par
\par
Call this function at any time to know the current mouse x position.\par
\par
Notes:\par
\par
The position is given in pixel units, and ranges depending on the actual\par
mouse range box. This can be changed by calling DQBsetMouseRange.\par
\par
\par
Example:\par
\par
See DQBmouseInit example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBmouseY FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBmouseY ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
An INTEGER value holding the current mouse y coordinate\par
\par
\par
Description:\par
\par
Call this function at any time to know the current mouse y position.\par
\par
Notes:\par
\par
The position is given in pixel units, and ranges depending on the actual\par
mouse range box. This can be changed by calling DQBsetMouseRange.\par
\par
\par
Example:\par
\par
See DQBmouseInit example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBmPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBmPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                     BYVAL SpriteOff, BYVAL Flip)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the sprite data; use VARPTR\par
\lang1042\f1\u-1806?\lang1033\f0    Flip        Flip flag\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This function works almost like DQBput, but it allows the user to draw sprites\par
horizontally or vertically (or both them) flipped. The flip parameter tells\par
DQBmPut how to flip the sprite: 0 means the sprite will be drawn as is, 1 that\par
it'll look like as it was horizontally mirrored and 2 vertically mirrored.\par
A value of 3 (1+2) means that both effects will be applied to the sprite. You\par
can use the constants defined in DIRECTQB.BI to simplify your calls; see\par
appendix A for details.\par
\par
\par
Notes:\par
\par
DQBmPut supports transparency and clipping; see also DQBput.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBnumDrives FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBnumDrives\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
An INTEGER value holding the number of drives\par
\par
\par
Description:\par
\par
This function returns the number of available logical drives. A value of 3\par
for example means you have A: B: and C:, and so on.\par
\par
Notes:\par
\par
See also DQBdir$, DQBpath$, DQBdrive$, DQBsetDrive\par
\par
\par
Example:\par
\par
See DQBdir$ example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBopenDataFile FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBopenDataFile (FileName AS STRING, Password AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    Datafile to open\par
\lang1042\f1\u-1806?\lang1033\f0    Password    Password for data decoding\par
\par
Returns:\par
\par
>   0     Operation successful\par
>   1     Cannot open file or file does not exist\par
>   2     General file reading error\par
>   3     Bad datafile format\par
>   4     Can't open two datafiles at once\par
\par
\par
Description:\par
\par
Opens a datafile and sets decoding password. The datafile must have been\par
created by the DQB DataFile Encoder program, or any other program able to\par
generate DQB compatible datafiles. Password can be any string up to 8 chars.\par
\par
Notes:\par
\par
As password, you can also pass a null string, meaning the datafile is not\par
password-protected. You cannot open two datafiles at once: if you need to\par
access the data that's stored onto another file, you must first close the\par
current opened one with the DQBcloseDataFile function. See also DQBunpackImage,\par
DQBunpackSprite, DQBunpackSound, DQBunpackPal, DQBunpackBMap, DQBunpackFont,\par
DQBunpackCursor, DQBunpackUser, and appendix C for the datafile file format\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' This example assumes there's a datafile named TEST.BIN, containing an image\par
' whose ID is SAMPLE (stored into TEST.BI).\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Here we include the BI file generated by DQBENC for our datafile\par
'$INCLUDE:'TEST.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Opens datafile TEST.BIN, using password PASS\par
IF DQBopenDataFile("TEST.BIN","PASS") THEN DQBclose: PRINT DQBerror$: END\par
\par
' Setups VGA\par
DQBinitVGA\par
\par
' Unpacks on the screen from TEST.BIN the image whose ID is SAMPLE, placing\par
' it at coordinates (0,0)\par
IF DQBunpackImage(SAMPLE, VIDEO, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Closes datafile (not really needed here, as DQBclose does it automatically)\par
DQBcloseDataFile\par
\par
' Ends program\par
DQBclose\par
END\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBopenFLI FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBopenFLI (FileName AS STRING, Frames AS INTEGER, Speed AS\par
                        INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    FLI animation file name\par
\lang1042\f1\u-1806?\lang1033\f0    Frames      Integer variable that will hold the total frames number\par
\lang1042\f1\u-1806?\lang1033\f0    Speed       Integer variable that will hold the animation speed factor\par
\par
Returns:\par
\par
>   0     Operation successful\par
>   1     Not enough free base memory\par
>   2     Cannot open file or file does not exist\par
>   3     General file reading error\par
>   4     Bad or unknown file format\par
>   5     A FLI file has already been opened\par
\par
\par
Description:\par
\par
Opens a FLI file and initializes the animation. The DQB internal FLI routines\par
cannot handle more than one file opened at the same time, so if you call this\par
function and then you try to call it again, or to call DQBplayFLI, you'll get\par
error 5; an animation file can be closed by using the DQBclose function.\par
DQBopenFLI also allows you to know the number of frames and the speed of the\par
specified FLI file, by passing QB variables to the function.\par
\par
Notes:\par
\par
As for normal DQBplayFLI, also this function requires 64K of additional\par
conventional memory as decoding buffer. See also DQBcloseFLI, DQBplayFLIstep,\par
DQBplayFLI\par
\par
\par
Example:\par
\par
See DQBplayFLIstep example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpaint SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBpaint (BYVAL Layer, BYVAL x, BYVAL y, BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to act\par
\lang1042\f1\u-1806?\lang1033\f0    x           X coordinate where to start filling\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y coordinate where to start filling\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Filling color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
As normal PAINT statement, this function fills any closed area, by starting\par
to fill at specified coordinates; the area is filled until a border with a\par
color different from specified one is encountered.\par
\par
Notes:\par
\par
Actually this function is slower than normal PAINT, but unlike it, DQBpaint\par
has the advantage that it fills only until a border with any different color\par
is hit.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Draws a closed figure on the screen\par
DQBellipse VIDEO, 160, 100, 100, 60, 40\par
DQBbox VIDEO, 100, 30, 150, 110, 11\par
\par
' Paints it!\par
DQBpaint VIDEO, 160, 100, 4\par
\par
' Let's wait for the user to press a key...\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpalOff SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBpalOff ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
By calling this function, the current palette is all set to black. This can\par
be used to turn off the screen when preparing it.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpalRotate SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBpalRotate (BYVAL FirstCol, BYVAL LastCol, BYVAL RotDir)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    FirstCol    First color index of palette interval to rotate\par
\lang1042\f1\u-1806?\lang1033\f0    LastCol     Last color index of palette interval to rotate\par
\lang1042\f1\u-1806?\lang1033\f0    RotDir      Rotating direction flag\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Rotates forward or backward the interval of the current palette specified by\par
the FirstCol and LastCol parameters. If RotDir is 0, the palette is rotated\par
forward, otherwise backward; you can use the FORWARD or BACKWARD constants\par
defined into DIRECTQB.BI, as explained into appendix A\par
\par
Notes:\par
\par
LastCol must be greater or equal than FirstCol. See also DQBsetCol, DQBgetCol,\par
DQBsetPal and DQBgetPal\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpath$ FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBpath$ ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
A string holding the current drive path\par
\par
\par
Description:\par
\par
DQBpath$ returns the actual full path of the current drive; Windows long\par
directory names are supported.\par
\par
Notes:\par
\par
See also DQBdir$, DQBdrive$, DQBnumDrives, DQBsetDrive\par
\par
\par
Example:\par
\par
See DQBdir$ example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpauseSound SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBpauseSound ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Pauses voices sound output.\par
\par
Notes:\par
\par
See also DQBresumeSound\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpeek SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBpeek (BYVAL DataSeg, BYVAL DataOff, BYVAL Offset AS LONG,\par
                     BYVAL Length)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    DataSeg     Segment of QB array or variable where data is copied from EMS\par
\lang1042\f1\u-1806?\lang1033\f0    DataOff     Offset of QB array or variable where data is copied from EMS\par
\lang1042\f1\u-1806?\lang1033\f0    Offset      Absolute offset into allocated EMS memory where to take data\par
\lang1042\f1\u-1806?\lang1033\f0    Length      Length in bytes to copy\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
DQBpeek allows to copy data from the user EMS memory area (whose dimension was\par
set by the third parameter of the DQBinit function) into a QB array or\par
variable. The Offset parameter specifies in byte units where to begin copying\par
data; this offset is absolute, and this means you refer to your user EMS\par
memory poll as a flat table. Length bytes are copied from EMS.\par
\par
Notes:\par
\par
This function works best with big amount of data; see also DQBpoke\par
\par
\par
Example:\par
\par
See DQBpoke example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBplayFLI FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBplayFLI (FileName AS STRING, BufLayer AS INTEGER, KeyStop\par
                             AS INTEGER, LoopFlag AS INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    FLI file name\par
\lang1042\f1\u-1806?\lang1033\f0    BufLayer    Layer to be used for double buffering\par
\lang1042\f1\u-1806?\lang1033\f0    KeyStop     Scancode of the stop key\par
\lang1042\f1\u-1806?\lang1033\f0    LoopFlag    Flag for animation looping\par
\par
Returns:\par
\par
>   0     Operation successful\par
>   1     Not enough free base memory\par
>   2     Cannot open file or file does not exist\par
>   3     General file reading error\par
>   4     Bad or unknown file format\par
\par
\par
Description:\par
\par
Plays a whole animation from a specified FLI file; actually, FLC files are not\par
supported. The file can be played using a double buffer, to achieve\par
flickerless animations: using this feature requires an additional existing\par
layer number to be specified into the "BufLayer" parameter; this layer can be\par
in EMS as well as in conventional memory. If you tell the function to use the\par
VIDEO as the needed layer, the animation will be decoded directly onto the\par
screen, avoiding the double buffering. On fast computers this will look almost\par
the same as if the buffer is used, but on older machines it is recommended\par
that you always use buffered decoding. The animation can be looped, and you\par
can also specify a key to stop it at any time and return the execution to your\par
program. By specifying KEYANY as "KeyStop" parameter, the player will stop\par
once any key is pressed; if you don't want to allow the user to stop an\par
animation, pass NONE as this parameter. The use of the stop key feature\par
requires that the DirectQB keyboard handler has been previously installed,\par
otherwise the function will ignore any keyboard strokes. The last parameter\par
tells DQBplayFLI whenever to loop the animation once the last frame is\par
reached; you can use the ONCE and LOOPED constants here. To avoid infinite\par
loops, if you want to play a looped animation you must also specify a stop\par
key, and therefore you must first install the keyboard handler. If no stop\par
key is defined, and you try to play an animation with looping, it'll be\par
played as if the ONCE mode was selected.\par
\par
Notes:\par
\par
Other than the layer used for double buffering, this function also requires\par
64K of free conventional memory for fast decoding purposes. As always, you\par
should call SETMEM to free some memory from the QB far heap, so that DQB\par
functions can use it. If you're also using a blender map, and you don't have\par
so much free base mem, you may want to call DQBremoveBmap before calling\par
DQBplayFLI, and then reallocate it after the animation ends; this way only\par
64K of memory are required. If you want to have more control over the\par
animation (like adding text over each frame before showing it, or changing\par
the playback speed), you can use the DQBopenFLI, DQBplayFLIstep and\par
DQBcloseFLI functions; check them out!\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with one extra layer and no sounds nor EMS\par
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Prompts the user for the FLI file name\par
INPUT "Enter full FLI file name (hit enter to quit): ", FileName$\par
\par
' Switches to VGA mode\par
DQBinitVGA\par
\par
' Installs the keyboard handler\par
DQBinstallKeyboard\par
\par
' Frees 64K of memory for animation decoding\par
dummy& = SETMEM(-66000)\par
\par
IF FileName$ <> "" THEN\par
\par
  ' Plays looped animation, using layer 1 for double buffering\par
  IF DQBplayFLI(FileName$, 1, KEYANY, LOOPED) THEN\par
    ' An error has occured\par
    DQBclose\par
    PRINT DQBerror$\par
    dummy& = SETMEM(66000)\par
    END\par
\par
  END IF\par
\par
END IF\par
\par
' The animation stops whenever the user press any key\par
DQBclose\par
dummy& = SETMEM(66000)\par
END\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBplayFLIstep SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBplayFLIstep (BYVAL Layer)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where the frame has to be drawn onto\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Decodes the next frame of a FLI file onto a specified layer. The animation\par
must have been opened with DQBopenFLI before calling this function; on errors\par
DQBplayFLIstep will do nothing. When the last frame is reached, this sub will\par
automatically restart from the first one, so it's up to the user to stop the\par
animation at the right time. It's also up to the user to add a proper delay\par
before copying the frame onto the screen: by the way, DQBopenFLI returns both\par
the total number of frames and the speed factor of the FLI file to be opened.\par
The speed factor can be used as a parameter to the DQBwait function, to\par
achieve the default animation speed.\par
\par
Notes:\par
\par
Of course you can decode each frame directly onto the screen, but as explained\par
into the description of the DQBplayFLI routine, this could not look so good\par
on older computers... Also, keep in mind that by calling this function, the\par
palette may change at any time as the FLI animation is playing. In addition,\par
you should know that when a new frame is decoded onto a layer, only the parts\par
of it that are changed from the last frame are drawn (that's the FLI standard)\par
so if you plan to draw some moving stuff over the animation, you should\par
always decode each frame onto the same layer, copy this layer onto a new one,\par
and then draw your own stuff on this last one before copying it on the screen.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' This program does the exact thing as the example of DQBplayFLI, but this\par
' one uses the three functions DQBopenFLI, DQBplayFLIstep and DQBclose to\par
' achieve the result.\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's declare two variables to hold the number of frames and speed factor\par
DIM FramesNumber AS INTEGER, SpeedFactor AS INTEGER\par
\par
' Initializes the library with one extra layer and no sounds nor EMS\par
IF DQBinit(2, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Prompts the user for the FLI file name\par
INPUT "Enter full FLI file name (hit enter to quit): ", FileName$\par
\par
IF FileName$ = "" THEN DQBclose: END\par
\par
' Frees 64K of memory for animation decoding\par
dummy& = SETMEM(-66000)\par
\par
' Opens the animation file and gets infos on it\par
IF DQBopenFLI(FileName$, FramesNumber, SpeedFactor) THEN\par
  ' An error has occured\par
  DQBclose\par
  dummy& = SETMEM(66000)\par
  PRINT DQBerror$: END\par
END IF\par
\par
' Shows some stats to the user\par
PRINT FileName$ + " contains" + STR$(FramesNumber) + " frames and has a ";\par
PRINT "speed factor of" + STR$(SpeedFactor)\par
PRINT "Press a key to continue..."\par
WHILE INKEY$ = "": WEND\par
\par
' Switches to VGA mode\par
DQBinitVGA\par
\par
' Plays the animation and automatically loops it\par
DO\par
  ' Decodes next frame on layer 2\par
  DQBplayFLIstep 2\par
\par
  ' Copies new frame into layer 1, so we can draw on it without problems\par
  DQBcopyLayer 2, 1\par
\par
  ' Now the frame has been drawn onto layer 1; you can do your stuff here\par
  ' ...\par
\par
  ' Adds delay and copies the frame onto the screen\par
  DQBwait SpeedFactor\par
  DQBcopyLayer 1, VIDEO\par
LOOP WHILE INKEY$ = ""\par
\par
' The animation stops whenever the user press any key\par
' Closes the FLI file\par
DQBcloseFLI\par
\par
' Ends program\par
DQBclose\par
dummy& = SETMEM(66000)\par
END\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBplaySound SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBplaySound (BYVAL Slot, BYVAL Voice, BYVAL Freq, BYVAL LoopFlag)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Slot        Slot holding the sound data\par
\lang1042\f1\u-1806?\lang1033\f0    Voice       Sound channel to use\par
\lang1042\f1\u-1806?\lang1033\f0    Freq        Playing frequency\par
\lang1042\f1\u-1806?\lang1033\f0    LoopFlag    Specifies to play the sound once or repeatedly\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Plays a sound effect previously stored into EMS by the DQBloadSound function\par
into a specified slot. The voice parameter can range from 1 to the maximum\par
number of voices specified when calling DQBinstallSB, and tells which sound\par
channel to use. If LoopFlag is 0, the sound is played once, while if the\par
LoopFlag is 1 the sound is looped. There are two constants defined into\par
DIRECTQB.BI that helps you using the LoopFlag parameter: they are the ONCE\par
and the LOOPED constants. The DQB sound engine supports sound resampling:\par
you specify the output frequency for each sound you play, and the sound will\par
be resampled and played in realtime.\par
\par
Notes:\par
\par
If you play a sound while another one is still playing on the same voice,\par
the old one is stopped and the new starts. To stop any sound playing on a\par
voice, call DQBstopVoice.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layer nor EMS, and one sound\par
IF DQBinit(0, 1, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Frees 16K of base memory for the sound engine volume table\par
dummy& = SETMEM(-17000)\par
\par
' Initializes the sound engine, by passing 220h as the base address and by\par
' autodetecting the IRQ and DMA settings. 2 voices are initialized, sampling\par
' rate is set to 22 KHz, and the volume table is built.\par
IF DQBinstallSB(TRUE, 2, 22050, &H220, AUTO, AUTO) THEN\par
    ' Bad initialization\par
    DQBclose\par
    PRINT DQBerror$\par
    END\par
END IF\par
\par
' Asks the user for the location of a WAV file to load\par
INPUT "Insert the WAV file name to load:", File$\par
\par
' Loads the sound in memory\par
IF DQBloadSound(1, File$) THEN DQBclose: PRINT DQBerror$: END\par
\par
PRINT "Press a key to exit..."\par
\par
' Plays sound 1 at 22 Khz on voice 2 once\par
DQBplaySound 1, 2, 22050, ONCE\par
\par
' Waits a key\par
WHILE INKEY$ = "": WEND\par
\par
' Turns off the sound engine (that's not really needed, as it's automatically\par
' done for you by the DQBclose function)\par
DQBremoveSB\par
\par
' Ends program\par
DQBclose\par
dummy& = SETMEM(17000)\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpoint FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBpoint (BYVAL Layer, BYVAL x, BYVAL y)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to get the pixel from\par
\lang1042\f1\u-1806?\lang1033\f0    x           Pixel x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y           Pixel y coordinate\par
\par
Returns:\par
\par
An INTEGER value holding the color number of specified pixel\par
\par
\par
Description:\par
\par
Call this function to retrieve the color number of a specified pixel.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpoke SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBpoke (BYVAL DataSeg, BYVAL DataOff, BYVAL Offset AS LONG,\par
                     BYVAL Length)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    DataSeg     Segment of QB array or variable where is data to copy to EMS\par
\lang1042\f1\u-1806?\lang1033\f0    DataOff     Offset of QB array or variable where is data to copy to EMS\par
\lang1042\f1\u-1806?\lang1033\f0    Offset      Absolute offset into allocated EMS memory where to copy data\par
\lang1042\f1\u-1806?\lang1033\f0    Length      Length in bytes to copy\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
DQBpoke is used to write data from a QB array or variable, into the user EMS\par
memory poll; you must specify the address and the length in bytes of the\par
source data, plus an offset into EMS where to copy it. As for DQBpeek, this\par
address is absolute, so you refer to your user EMS area as a flat memory area.\par
\par
Notes:\par
\par
Never try to copy data when it (or a part of it) will lie outside the user\par
EMS memory area set by the DQBinit function; you may end with a machine crash.\par
See also DQBpeek\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE: 'directqb.bi'\par
\par
' Let's initialize the library with no layers nor sounds, but 100KB of EMS\par
IF DQBinit(0, 0, 100) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Here we declare a string we'll copy to EMS\par
DIM Text AS STRING * 30\par
Text = "This is a test!!"\par
\par
' Let's display our string\par
PRINT "Now the string is: " + Text\par
\par
' Copies the string to EMS, at address 0 of our user memory area\par
DQBpoke VARSEG(Text), VARPTR(Text), 0, 30\par
\par
' Clears our string and display it\par
Text = ""\par
PRINT "Now the string is: " + Text\par
\par
' Gets back the string from the EMS user memory area\par
DQBpeek VARSEG(Text), VARPTR(Text), 0, 30\par
\par
' Displays it again\par
PRINT "Now the string is: " + Text\par
\par
' Ends program\par
DQBclose\par
END\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpollJoy SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBpollJoy (BYVAL JoyNum)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    JoyNum      Joystick number to retrieve information of\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This function must be always called before calling DQBjoyMove or DQBjoyFire,\par
as it updates the internal joystick variables. The JoyNum parameter must be\par
0 or 1 for joystick 1 and 2; there're two contants for this purpose, as\par
explained into appendix A.\par
\par
Notes:\par
\par
This is a relatively slow operation; in addition, if specified joystick is\par
not connected, this will be even slower, so it is recommended that you check\par
if the joystick is available before calling DQBpollJoy.\par
\par
\par
Example:\par
\par
See DQBjoyMove example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBpPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                     BYVAL SpriteOff, BYVAL Pattern)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the sprite data; use VARPTR\par
\lang1042\f1\u-1806?\lang1033\f0    Pattern     Bit pattern (see below)\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Draw a sprite as DQBput, but uses a specified 8-bit pattern to determine which\par
pixel is to be drawn or not. So if the pattern looks like 01010101 (number 85\par
in decimal format), one pixel will be drawn, and the next one will be skipped,\par
then the process begins again. The pattern wraps until the end of each sprite\par
line, and on every new line it's xored by 255: this means that the same\par
example pattern will look like 10101010 on the second sprite line, and again\par
as 01010101 on the third, etc...\par
\par
Notes:\par
\par
By alternating the bit-pattern and drawing sprites quickly using this function,\par
you can achieve translucency-like effects, but without the need of a blender\par
map. Use it wisely!\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBprint SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBprint (Layer AS INTEGER, Text AS STRING, x AS INTEGER,\par
                      y AS INTEGER, Col AS INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the text\par
\lang1042\f1\u-1806?\lang1033\f0    Text        String to print\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the first character\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the first character\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Text color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This function will print the specified string onto the given layer. By\par
default, the VGA BIOS font is used, but any font can be used by first calling\par
DQBsetFont. Also, the last style selected by DQBsetTextStyle is used. The x\par
and y parameters are in pixel units, so you can print the text anywhere on\par
specified layer. If you specify a x value of &H8000 (or you type in the\par
constant CENTERED - see appendix A) the text is automatically centered on\par
the current viewport set by the last call to DQBsetClipBox (that's by default\par
the entire screen)\par
\par
Notes:\par
\par
DQBprint supports clipping, so pixels outside the clipping box will not be\par
drawn. See also DQBprints, DQBsetTextStyle, DQBsetFont and DQBsetBIOSfont.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Prints text on the center of the screen in bright red\par
DQBprint VIDEO, "This is a DQBprint test!", CENTERED, 96, 40\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBprints SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBprints (Layer AS INTEGER, Text AS STRING, x AS INTEGER,\par
                       y AS INTEGER, Col AS INTEGER, Style AS INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the text\par
\lang1042\f1\u-1806?\lang1033\f0    Text        String to print\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the first character\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the first character\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Text color\par
\lang1042\f1\u-1806?\lang1033\f0    Style       Custom text style\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
DQBprints works exactly like DQBprint, but it requires an additional parameter\par
that allows to specify the style of the output text. Specified style is\par
applied only to one call of this function; once the text has been drawn, the\par
original text style is restored. For the styles, see appendix A for a list of\par
constants, and take a look at the DQBsetTextStyle function.\par
\par
Notes:\par
\par
DQBprints supports clipping, so pixels outside the clipping box will not be\par
drawn. See also DQBprint, DQBsetTextStyle, DQBsetFont and DQBsetBIOSfont.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Uses normal font with DQBprint\par
DQBprint VIDEO, "This is a normal text", 0, 0, 31\par
\par
' Uses normal font with the bold style\par
DQBprints VIDEO, "I'm big and fat, I'm bold style!", 0, 10, 31, BOLD\par
' Uses italic style on the same font\par
DQBprints VIDEO, "Italic style is very nice", 0, 20, 31, ITALIC\par
' Uses underlined style again on the same font\par
DQBprints VIDEO, "Pay attention to underlined text", 0, 30, 31, UNDERLINED\par
' Uses a combination of styles on the same font\par
DQBprints VIDEO, "Bold and italic together!", 0, 40, 31, BOLD + ITALIC\par
\par
' Back to normal text\par
DQBprint VIDEO, "That's all folks!", 0, 50, 31\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBpset SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBpset (BYVAL Layer, BYVAL x, BYVAL y, BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the pixel\par
\lang1042\f1\u-1806?\lang1033\f0    x           Pixel x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y           Pixel y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Pixel color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets a pixel onto specified layer, at given coordinates and with Col color.\par
\par
Notes:\par
\par
This function is affected by the clipping box set by DQBsetClipBox.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBput SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBput (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                    BYVAL SpriteOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the sprite data; use VARPTR\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Draws the sprite contained into the given array on specified layer, at the\par
given coordinates. DQBput can operate both in transparent and solid mode:\par
when the first mode is set, pixels with color 0 of the sprite are skipped,\par
allowing a transparent put, when the second mode is set, all the pixels are\par
copied to the layer, destroying the background. By default the put mode is\par
set to transparent, but it can be changed at any time by simply calling\par
DQBsetTransPut and DQBsetSolidPut.\par
\par
Notes:\par
\par
DQBput is affected by the clipping box, so pixels outside this box will not\par
be drawn. The sprite data format is compatible with normal GET and PUT, so\par
you can get you sprite data by calling either GET or DQBget. See also DQBfPut,\par
DQBsPut, DQBrPut and DQBbPut.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE: 'DIRECTQB.BI'\par
\par
' Let's initialize the library with one extra layer and no sounds nor EMS\par
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' We're going to use 15 sprite 16x16 pixels each; let's call DQBsize to\par
' know the dimension of our sprite array (we'll store all the sprites into\par
' the same array) in bytes\par
Size = DQBsize(0, 0, 15, 15)\par
' Our array is made of INTEGERs, so we divide Size by 2\par
DIM Sprite((Size \\ 2) * 15)\par
\par
' Let's prepare our sprites\par
FOR i = 0 TO 14\par
\par
  ' Let's clear layer 1\par
  DQBclearLayer 1\par
\par
  ' Draws a frame of our sprite\par
  DQBbox 1, 0, 0, 15, 15, 4\par
  DQBline 1, (15-i), 15, i, 0, 40\par
  DQBline 1, 15, i, 0, (15 - i), 40\par
\par
  ' Saves the frame into our array\par
  DQBget 1, 0, 0, 15, 15, VARSEG(Sprite(0)), VARPTR(Sprite(0)) + (Size * i)\par
\par
NEXT i\par
\par
DQBinitVGA\par
\par
FOR i = -16 TO 320\par
\par
  ' Empties layer 1\par
  DQBclearLayer 1\par
\par
  ' Finds what frame to draw\par
  Frame = ((i + 16) \\ 2) MOD 15\par
\par
  ' Draws our frame into layer 1\par
  DQBput 1, i, 92, VARSEG(Sprite(0)), (VARPTR(Sprite(0)) + (Size * Frame))\par
\par
  ' Waits for vertical retrace 1 time\par
  DQBwait 1\par
\par
  ' Copies layer 1 onto the screen\par
  DQBcopyLayer 1, VIDEO\par
\par
NEXT i\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
-----------------------------------------------------------------------------\par
DQBputOver SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBputOver (BYVAL BackSeg, BYVAL BackOff, BYVAL x, BYVAL y,\par
                        BYVAL SpriteSeg, BYVAL SpriteOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    BackSeg     Segment of the array holding the 1st sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    BackOff     Offset of the array holding the 1st sprite data; use VARPTR\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the 2nd sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the 2nd sprite data; use VARPTR\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This function allows to draw a sprite over another one. The 1st sprite acts\par
as the background, and the second one is drawn over it; DQBputOver supports\par
transparency and the 2nd sprite is automatically clipped to the first one.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBreadBit FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBreadBit (BYVAL Value, BYVAL Bit)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Value       INTEGER value to read bit status from\par
\lang1042\f1\u-1806?\lang1033\f0    Bit         Bit number, ranging 0-15, to retrieve status of\par
\par
Returns:\par
\par
True if specified bit is set, otherwise false\par
\par
\par
Description:\par
\par
This function returns true if a specified bit of a specified integer value\par
is set. It can be useful to store boolean variables into an unique INTEGER\par
one, as QB does not support booleans. An integer can contain up to 16 boolean\par
variables!\par
\par
Notes:\par
\par
See DQBsetBit, DQBresetBit and DQBtoggleBit\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBreadKey FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBreadKey ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
An INTEGER value holding the scancode number of the key that has been pressed\par
\par
\par
Description:\par
\par
DQBreadKey wait for the user to press a key, and then returns its scancode.\par
This function works only if the keyboard interrupt handler has been installed\par
by calling DQBinstallKeyBoard.\par
\par
Notes:\par
\par
See DQBinstallKeyboard, DQBkey, DQBwaitKey\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBremoveBMap SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBremoveBMap (BYVAL BMap)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Blender map number to deallocate  \par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Deallocates memory used by specified blender map and turns it off.\par
\par
Notes:\par
\par
This function is automatically called by DQBclose for every active bmap. See\par
also DQBcreateBMap\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBremoveKeyboard SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBremoveKeyboard ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Turns off the custom keyboard interrupt handler if it was on, giving the\par
keyboard control back to the old BIOS routines. This function is automatically\par
called by DQBclose.\par
\par
Notes:\par
\par
See also DQBinstallKeyboard\par
\par
\par
Example:\par
\par
See DQBkey example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBremoveSB SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBremoveSB ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Stops all the sounds playing and turns off the sound engine. This function is\par
automatically called for you by DQBclose, so there's no particular need to\par
call it.\par
\par
Notes:\par
\par
See also DQBinstallSB\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBresetBit FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBresetBit (BYVAL Value, BYVAL Bit)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Value       INTEGER variable to reset bit of\par
\lang1042\f1\u-1806?\lang1033\f0    Bit         Bit number to reset, ranging 0-15\par
\par
Returns:\par
\par
An INTEGER value representing the old variable value with specified bit reset\par
\par
\par
Description:\par
\par
Call this function to zero a bit of a specified variable. This can be useful\par
to handle boolean variables.\par
\par
Notes:\par
\par
See DQBsetBit, DQBreadBit and DQBtoggleBit\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBresetJoy SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBresetJoy ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Resets the joysticks by recalibrating them (where they are available).\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
\par
-----------------------------------------------------------------------------\par
DQBresetMouse SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBresetMouse ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Resets the default mouse cursor shape and sets mouse range to (0,0)-(319,199).\par
This function should be called just after entering mode 13h.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBresumeSound SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBresumeSound ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Resume sound output paused by DQBpauseSound.\par
\par
Notes:\par
\par
See also DQBpauseSound\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBrPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBrPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                     BYVAL SpriteOff, BYVAL Angle, BYVAL Zoom)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the sprite data; use VARPTR\par
\lang1042\f1\u-1806?\lang1033\f0    Angle       Rotation angle ranging 0-255\par
\lang1042\f1\u-1806?\lang1033\f0    Zoom        Zoom factor\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
DQBrPut draws a sprite rotated and scaled of the specified values. The angle\par
can range from 0 to 255 (256=0), while the zoom factor represents the zooming\par
percentage: a value of 100 will draw the sprite in its original size, a value\par
of 50 will draw a sprite of half its original size, etc... The rotation uses\par
a pixel-perfect algorithm, but rotated pixels that lie outside the original\par
sprite mask will not be drawn; this means that if you want to rotate a sprite\par
without loosing graphics, you must get it into a bigger area. For example,\par
let's suppose you have a 16x16 pixels sprite: you should get an area of 22x22\par
pixels to be sure not to loose any pixel when rotating. The same goes when\par
zooming in: the original sprite area is respected.\par
\par
Notes:\par
\par
DQBrPut supports clipping and transparency. See also DQBput, DQBfPut, DQBsPut\par
and DQBbPut.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE: 'DIRECTQB.BI'\par
\par
' Let's initialize the library with one extra layer and no sounds nor EMS\par
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Let's use an 80x80 pixels sprite\par
Size = DQBsize(0, 0, 79, 79)\par
' Our array is made of INTEGERs, so we divide Size by 2\par
DIM Sprite(Size \\ 2)\par
\par
' Let's prepare our sprite\par
DQBclearLayer 1\par
DQBprint 1, "DirectQB!", 8, 36, 40\par
DQBget 1, 0, 0, 79, 79, VARSEG(Sprite(0)), VARPTR(Sprite(0))\par
\par
DQBinitVGA\par
\par
FOR i = 0 TO 90\par
\par
  ' Empties layer 1\par
  DQBclearLayer 1\par
\par
  ' Draws our roto-zoomed sprite into layer 1\par
  DQBrPut 1, 120, 60, VARSEG(Sprite(0)), VARPTR(Sprite(0)), (90 - i), (10 + i)\par
\par
  ' Waits for vertical retrace 1 time\par
  DQBwait 1\par
\par
  ' Copies layer 1 onto the screen\par
  DQBcopyLayer 1, VIDEO\par
\par
NEXT i\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsaveBMap FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBsaveBMap (BMap AS INTEGER, FileName AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Number of the blender map to save\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    Blender map file name with full extension\par
\par
Returns:\par
\par
An INTEGER value holding the saving results:\par
\par
>   0     Operation successful\par
>   1     Blender map not yet created\par
>   2     Cannot create file or disk error\par
>   3     Unable to write data or disk full\par
\par
\par
Description:\par
\par
This function saves the specified blender map data to disk. The bmap can be\par
then loaded again in memory by calling DQBloadBMap.\par
\par
Notes:\par
\par
See also DQBcreateBMap, DQBloadBMap\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsaveImage FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBsaveImage (Layer AS INTEGER, x1 AS INTEGER, y1 AS INTEGER,\par
                               x2 AS INTEGER, y2 AS INTEGER, FileName AS\par
                               STRING, Pal AS STRING, Format AS INTEGER)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where is the image to save\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x coordinate of upper-left area of layer to save\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y coordinate of upper-left area of layer to save\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x coordinate of lower-right area of layer to save\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y coordinate of lower-right area of layer to save\par
\lang1042\f1\u-1806?\lang1033\f0    FileName    New image file name with full extension\par
\lang1042\f1\u-1806?\lang1033\f0    Pal         String holding the palette to save\par
\lang1042\f1\u-1806?\lang1033\f0    Format      Image file format\par
\par
Returns:\par
\par
An INTEGER value holding the saving results:\par
\par
>   0     Operation successful\par
>   1     Cannot create file or disk error\par
>   2     Unable to write data or disk full\par
\par
\par
Description:\par
\par
Call this function to save an area of a layer to a file. Images can be saved\par
in three different formats: BSAVE compatible, BMP or PCX. When saving in the\par
BSAVE format, you can load the image by simply calling the QB command BLOAD,\par
and the palette will be appended to the end of the file. In addition, BSAVEd\par
images are large files, but they're the fastest to load. When using the BMP\par
format, the resulting file will be even larger, but you'll have a image saved\par
into a standard file format, editable by most of the commercial image-editing\par
programs. PCX is the smallest available file format, and contains the palette,\par
but it's also the slowest to load. The palette to save with the file must have\par
been previously stored into a string as explained into appendix A, by calling\par
DQBgetPal or even DQBloadLayer. This is done to allow saving hidden layers\par
with a palette different from the current one.\par
\par
Notes:\par
\par
When you're saving in the BSAVE format an image that's 320x200 pixels, it'll\par
be saved just like the QB command\par
\par
              DEF SEG = <layerseg>: BSAVE <imagefile>, 0, 64000\par
\par
So you'll be able to load it on the screen without requiring an intermediate\par
buffer. On the other hand, if you use the BSAVE format to save an image that's\par
smaller than 320x200, it'll be like if you used\par
\par
                       GET (x1, y1)-(x2, y2), <array>\par
   DEF SEG = VARSEG(<array>): BSAVE <imagefile>, VARPTR(<array>), <length>\par
\par
In both cases, the palette will be appended to the file; but don't worry,\par
because BLOAD will be still able to load your images - though without loading\par
the appended palette.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBscroll SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBscroll (BYVAL Layer, BYVAL dx, BYVAL dy)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer to be scrolled\par
\lang1042\f1\u-1806?\lang1033\f0    dx          Horizontal scrolling offset\par
\lang1042\f1\u-1806?\lang1033\f0    dy          Vertical scrolling offset\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Scrolls selected layer. A positive dx value will scroll the layer right, a\par
negative one will scroll it left. Positive dy value scrolls down, negative up;\par
by combining these parameters you can scroll the layer in any direction. The\par
newly visible area will be filled with garbage, to it's up to the programmer\par
to fill it with new graphics.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBscrollArea SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBscrollArea (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2,\par
                           BYVAL y2, BYVAL Direction)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer to be scrolled\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x coordinate of upper-left corner of area to scroll\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y coordinate of upper-left corner of area to scroll\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x coordinate of lower-right corner of area to scroll\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y coordinate of lower-right corner of area to scroll\par
\lang1042\f1\u-1806?\lang1033\f0    Direction   Scrolling direction\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Scrolls a specified area on a given layer. The area can be scrolled only by\par
one pixel at a time, and the direction parameter can range from 0 to 3,\par
representing up, down, left and right scrolling. You can use the UP, DOWN,\par
LEFT and RIGHT constants defined into the DIRECTQB.BI file for ease.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetBaseLayer FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBsetBaseLayer (BYVAL Layer)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer in conventional memory to allocate\par
\par
Returns:\par
\par
0 if base layer was already allocated or there's not enough free conventional\par
memory, otherwise the segment of the new memory block used as layer.\par
\par
\par
Description:\par
\par
DQBsetBaseLayer tryes to allocate conventional memory for a new base layer,\par
as specified by the Layer parameter. If successfull, this function returns\par
a segment address to the allocated memory chunk used as layer, which is\par
exactly 64000 bytes; then you can refer to this layer as you do with normal\par
layers in EMS memory.\par
\par
Notes:\par
\par
Keep in mind that base layers requires a lot of base memory, but they're\par
accessed a lot faster than normal EMS layers.\par
Also, before calling DQBsetBaseLayer you should free 64K of conventional\par
memory by calling the QB function SETMEM, as you do with DQBcreateBMap.\par
To refer to base layers you should always use the B0..B9 constants as\par
explained in appendix A.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE: 'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Releases memory for a base layer\par
dummy& = SETMEM(-66000)\par
\par
' Assign our array to base layer 0\par
Seg0 = DQBsetBaseLayer(B0)\par
IF Seg0 = 0 THEN\par
    ' Not enough memory\par
    DQBclose\par
    PRINT DQBerror$\par
    END\par
ELSE\par
    ' Prints some info\par
    PRINT "Layer allocated at address " + HEX$(Seg0) + ":0000"\par
    WHILE INKEY$ = "": WEND\par
END IF\par
\par
DQBinitVGA\par
\par
' Let's print some text on layer B0\par
DQBprint B0, "DirectQB!", 124, 96, 40\par
\par
' Copy layer B0 to the screen\par
DQBcopyLayer B0, VIDEO\par
\par
' Wait for the user to press a key...\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
dummy& = SETMEM(66000)\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetBIOSfont SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetBIOSfont ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Resets the current font to the standard VGA BIOS one. Nexts calls to DQBprint\par
will use the BIOS font.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBprint example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetBit FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBsetBit (BYVAL Value, BYVAL Bit)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Value       INTEGER variable to set bit of\par
\lang1042\f1\u-1806?\lang1033\f0    Bit         Bit number to set, ranging 0-15\par
\par
Returns:\par
\par
An INTEGER value representing the old variable value with the new bit set\par
\par
\par
Description:\par
\par
Call this function to set a bit of a specified variable. This can be useful\par
to create boolean variables.\par
\par
Notes:\par
\par
See DQBresetBit, DQBreadBit and DQBtoggleBit\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetBMap SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetBMap (BYVAL BMap, BYVAL ForeCol, BYVAL BackCol, BYVAL NewCol)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        BMap number to edit\par
\lang1042\f1\u-1806?\lang1033\f0    ForeCol     Foreground color\par
\lang1042\f1\u-1806?\lang1033\f0    BackCol     Background color\par
\lang1042\f1\u-1806?\lang1033\f0    NewCol      Color of the resulting combination\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets a color for the specified combination on the specified blender map. Never\par
try to set the combinations for an unmapped foreground color!\par
\par
Notes:\par
\par
See also DQBcreateBMap, DQBgetBMap, DQBloadBMap and DQBsaveBMap\par
\par
\par
Example:\par
\par
See DQBbPut example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetClipBox SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetClipBox (BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    x1          Upper left corner x coordinate of clipping box\par
\lang1042\f1\u-1806?\lang1033\f0    y1          Upper left corner y coordinate of clipping box\par
\lang1042\f1\u-1806?\lang1033\f0    x2          Lower right corner x coordinate of clipping box\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Lower right corner y coordinate of clipping box\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the current clipping box to (x1,y1)-(x2,y2). Next calls to all the\par
drawing functions (except DQBbox and DQBboxf) will be affected by the new\par
clipping box.\par
\par
Notes:\par
\par
The clipping box is set to (0,0)-(319,199) at startup.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetCol SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetCol (BYVAL Col, BYVAL Red, BYVAL Green, BYVAL Blue)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Col         Color to change\par
\lang1042\f1\u-1806?\lang1033\f0    Red         New red hue\par
\lang1042\f1\u-1806?\lang1033\f0    Green       New green hue\par
\lang1042\f1\u-1806?\lang1033\f0    Blue        New blue hue\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the hues of a given color index. The red, green and blue hues must be in\par
the range 0-63.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetCollideMethod SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetCollideMethod (BYVAL Method)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Method      Collision detection method to be used\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the collision detection method to be used by the DQBcollide function.\par
The method parameter can be 0 (bounding box check) or 1 (pixel-perfect check);\par
you can use the BOX and PIXEL constants for ease.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetDrive SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetDrive (Drive AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Drive       New drive letter\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
This function changes the current drive to the new one specified by the letter\par
of the Drive parameter.\par
\par
Notes:\par
\par
See also DQBdrive$, DQBchDir, DQBdir$, DQBpath$, DQBnumDrives\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetFont SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetFont (Font AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Font        String of 2305 characters holding the new font data\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the current font to specified one held into the Font string (see appendix\par
C for details on the font data format). Next calls to DQBprint or DQBprints\par
will use the new font to draw characters.\par
\par
Notes:\par
\par
You can use DirectQB Tools to create your own fonts. See also DQBsetBIOSfont\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetFontTexture SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetFontTexture (BYVAL TextSeg, BYVAL TextOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    TextSeg     Segment of the array holding the texture sprite (use VARSEG)\par
\lang1042\f1\u-1806?\lang1033\f0    TextOff     Offset of the array holding the texture sprite (use VARPTR)\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the texture to be used whenever the TEXTURED font style is used. Font\par
textures must be normal sprites got with GET or DQBget, but their size must\par
always be 8x8 pixels, otherwise you may end up with unpredictable effects.\par
Specified texture is then used to fill the active pixels of each character of\par
your string.\par
\par
Notes:\par
\par
Textures used as font textures do not support transparency. Also, the TEXTURED\par
style does not work when applied together with the BOLD one, due to internal\par
library limitations. If you apply this combination anyway, the BOLD effect\par
will not be considered (but the other effects will still work!).\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Dimension our 8x8 pixels texture array\par
DIM Texture(35)\par
\par
' Let's initialize the library with one extra layer and no sounds nor EMS\par
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Prepares the sprite that will be used as font texture on layer 1\par
FOR i = 0 TO 7\par
  DQBline 1, 0, i, i, 0, (31 - i)\par
NEXT i\par
FOR i = 0 TO 7\par
  DQBline 1, 7, i, i, 7, (24 - i)\par
NEXT i\par
\par
' Get the sprite!\par
DQBget 1, 0, 0, 7, 7, VARSEG(Texture(0)), VARPTR(Texture(0))\par
\par
' Let's set the font texture to our new one\par
DQBsetFontTexture VARSEG(Texture(0)), VARPTR(Texture(0))\par
\par
' Prints a string on the screen\par
DQBprints VIDEO, "This is a textured font test!!", 0, 100, 15, TEXTURED\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
END\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetFrameRate SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetFrameRate (BYVAL FPS)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    FPS         new frames per second selection\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets a new framerate. Together with the DQBframeReady function, this one can\par
be used to syncronize the graphics speed to a specified framerate, in an\par
independent way from the program complexity.\par
\par
Notes:\par
\par
DQBsetFrameRate alters the PC timer speed, so use caution when calling this\par
function; it may not be compatible with some TSR, like SBMIDI, so be warned.\par
See also DQBframeReady\par
\par
\par
Example:\par
\par
none\par
\par
-----------------------------------------------------------------------------\par
DQBsetFreq SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetFreq (BYVAL Voice%, BYVAL SampleRate%)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0   Voice        Voice to change the frequency of\par
\lang1042\f1\u-1806?\lang1033\f0   SampleRate   Frequency between 4000 to 32766 to change pitch\par
\par
Returns:\par
\par
none\par
\par
Description:\par
\par
Ever wanted that doppler effect in your racing game? This handy function\par
works well with looped voices, and it gives a very nice effect you hear\par
on SNES games. This function can be very useful, if you're making sound\par
oriented projects.\par
\par
Notes:\par
\par
Try to keep the frequency between 4000 to 32766. Use only the channels\par
you've initiated with DQBinstallSB.\par
\par
Example:\par
\par
'$INCLUDE: 'DIRECTQB.BI'\par
\par
' Initiate DQB\par
IF DQBinit(0, 1, 0) THEN DQBclose: END\par
\par
' Initiate sound engine\par
IF DQBinstallSB%(0, 32, 22050, -1, -1, -1) THEN DQBclose: END\par
\par
' Load up your sample\par
A$ = ????? ' Replace this with your WAV file\par
IF DQBloadSound%(1, A$) THEN DQBclose: END\par
\par
' Play sound on channel 2, from slot 1, and decrease its frequency\par
DQBplaySound 1, 2, 22050, 1\par
FOR I = 22050 TO 4000 STEP -5\par
 DQBsetFreq 2, I\par
 DQBwait 1\par
NEXT\par
\par
' Close everything and a message\par
DQBclose\par
PRINT DQBerror$\par
\par
-----------------------------------------------------------------------------\par
DQBsetMousePos SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetMousePos (BYVAL x, BYVAL y)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    x           x coordinate of new mouse position\par
\lang1042\f1\u-1806?\lang1033\f0    y           y coordinate of new mouse position\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the new mouse position to (x,y).\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetMouseRange SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetMouseRange (BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    x1          Upper left corner x coordinate of new range box\par
\lang1042\f1\u-1806?\lang1033\f0    y1          Upper left corner y coordinate of new range box\par
\lang1042\f1\u-1806?\lang1033\f0    x2          Lower right corner x coordinate of new range box\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Lower right corner y coordinate of new range box\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the new mouse range to (x1,y1)-(x2,y2).\par
\par
Notes:\par
\par
Mouse range is set to (0,0)-(319,199) at startup.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetMouseShape SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetMouseShape (hotX AS INTEGER, hotY AS INTEGER, Shape AS\par
                              STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    hotX        New cursor x hotspot coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    hotY        New cursor y hotspot coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    Shape       New cursor shape data string\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the new cursor shape to specified one. There's no need to hide the mouse\par
before calling this function, and then to show it again after the operation,\par
as this is automatically done for you by this function. See appendix C for\par
details on the mouse cursor shape data format.\par
\par
Notes:\par
\par
Call DQBresetMouse to restore the default mouse cursor shape. This will also\par
reset the mouse range box to (0,0)-(319,199), so be warned.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetMouseSpeed SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetMouseSpeed (BYVAL Hor, BYVAL Ver)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Hor         New horizontal mouse speed\par
\lang1042\f1\u-1806?\lang1033\f0    Ver         New vertical mouse speed\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the new mouse horizontal and vertical speed. By default, both speeds are\par
set to 16; smaller values will make the mouse movement faster, bigger values\par
will have the opposite effect.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetPal SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetPal (Pal AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Pal         New palette data string\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the current palette to the new specified one. See appendix C for details\par
on the palette data format.\par
\par
Notes:\par
\par
See also DQBgetPal\par
\par
\par
Example:\par
\par
See DQBfadeTo example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetSolidPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetSolidPut ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the solid put mode. Next calls to DQBput or DQBscaledPut will ignore\par
transparent color.\par
\par
Notes:\par
\par
See also DQBsetTransPut\par
\par
\par
Example:\par
\par
See DQBput example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetTextBackCol SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetTextBackCol (BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Col         New text background color\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the current text background color; this will be used only if in solid\par
text mode.\par
\par
Notes:\par
\par
By default, the text background color is 0. See also DQBsetTextStyle and\par
DQBprint.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetTextBMap SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetTextBMap (BYVAL BMap)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Blender map to be used\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the blender map to be used when the BLENDED text style is selected to\par
print text with DQBprint or DQBprints.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetTextSpacing SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetTextSpacing (BYVAL Spacing)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Spacing     Characters extra spacing in pixel\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
You can call this function to modify the spacing between characters drawn in\par
the current font with DQBprint or DQBprints. By default this value is 0 (that\par
means the spacing is the font default); by increasing it, you can add extra\par
spacing between each character printed.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetTextStyle SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetTextStyle (BYVAL Style)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Style       New text style\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the current text style used by DQBprint. The style is indipendent from\par
the current font; the available styles are bold, italic and underlined. To use\par
no styles just pass the NONE constant to this function. DQBsetTextStyle allows\par
also to set the transparent or solid text mode as well as support for color\par
blending and textured text; by default, the transparent mode is set, but by\par
passing the SOLID constant, next calls to DQBprint will print solid text. On\par
the other hand, to obtain blended text, just add the BLENDED constant, while\par
adding TEXTURED causes the current font texture to be used to print your text.\par
You can use combinations of all the styles, by simply adding the right\par
constants, that can be found in appendix A.\par
\par
Notes:\par
\par
The only styles combination that doesn't work is when you apply BOLD and\par
TEXTURED modes together. In this case, the first one is ignored. See also\par
DQBprint, DQBprints, DQBsetFontTexture\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Uses normal font with DQBprint\par
DQBprint VIDEO, "This is a normal text", 0, 0, 31\par
\par
' Let's set solid italic style...\par
DQBsetTextStyle SOLID + ITALIC\par
' ...and red background color\par
DQBsetTextBackCol 4\par
\par
' Prints something using the new style\par
DQBprint VIDEO, "And this is solid italic text!", 0, 50, 31\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetTextureSize SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetTextureSize (BYVAL Size)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Size        New texture width\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Unlike the name says, DQBsetTextureSize is used to set only the width of the\par
texture used by subsequent calls to DQBttri. The width must be specified in\par
pixels and must be a power of 2; values that are not powers of 2 will be\par
rounded to the previous power, so that if you give 63 the function will assume\par
it's a 32, and if you give a 64, it'll assume it's a 64, etc... There are no\par
limits about the height of a texture, you only have to care about the texel\par
coordinates of the vertexes of your triangle.\par
\par
Notes:\par
\par
By default, the texture size is set to 64; see also DQBttri.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetTransPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetTransPut ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the transparent put mode. Next calls to DQBput or DQBscaledPut will draw\par
transparent sprites.\par
\par
Notes:\par
\par
See also DQBsetSolidPut\par
\par
\par
Example:\par
\par
See DQBput example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetVoiceVol SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetVoiceVol (BYVAL Voice,BYVAL Volume)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Voice       Voice to change volume of\par
\lang1042\f1\u-1806?\lang1033\f0    Volume      New voice volume setting\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the volume setting for a specified voice; it may range from 0 to 63.\par
\par
Notes:\par
\par
By default the volume setting for all the voices is 63; remember that the\par
volume of a voice also depends on the master volume setting. This function\par
has no effect if the volume table is off (see DQBinstallSB for details)\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsetVolume SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsetVolume (BYVAL Volume)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Volume      New master volume setting\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Sets the master volume setting for sound output; it may range from 0 to 15.\par
\par
Notes:\par
\par
There's no default volume setting, so it is recommended that you set the\par
volume as you wish just after calling DQBinstallSB in your programs.\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBshiftLeft FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBshiftLeft (BYVAL Value, BYVAL NumBits)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Value       INTEGER value to shift\par
\lang1042\f1\u-1806?\lang1033\f0    NumBits     Number of bits to shift left\par
\par
Returns:\par
\par
An INTEGER value representing the shifted number\par
\par
\par
Description:\par
\par
Performs a logical shift left of the given integer value, and returns the\par
result. This can be useful to multiply by powers of 2 a given number, as this\par
operation is faster than *.\par
\par
Notes:\par
\par
See also DQBshiftRight\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBshiftRight FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBshiftRight (BYVAL Value, BYVAL NumBits)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Value       INTEGER value to shift\par
\lang1042\f1\u-1806?\lang1033\f0    NumBits     Number of bits to shift right\par
\par
Returns:\par
\par
An INTEGER value representing the shifted number\par
\par
\par
Description:\par
\par
Performs a logical shift right of the given integer value, and returns the\par
result. This can be useful to divide by powers of 2 a given number, as this\par
operation is faster than \\.\par
\par
Notes:\par
\par
See also DQBshiftLeft\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsize FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBsize (BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2)\par
\par
Calling:\par
                \par
\lang1042\f1\u-1806?\lang1033\f0    x1          Upper left corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y1          Upper left corner y coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    x2          Lower right corner x coordinate\par
\lang1042\f1\u-1806?\lang1033\f0    y2          Lower right corner y coordinate\par
\par
Returns:\par
\par
An INTEGER value holding the sprite size in bytes\par
\par
\par
Description:\par
\par
DQBsize returns the number of bytes needed to store the image contained into\par
the box given by (x1,y1)-(x2,y2) with DQBget. This value can be then used to\par
dimension arrays to store the sprite data for the DQBget and DQBput routines.\par
Remember that the array is made of INTEGERs while this function returns the\par
number of bytes; just divide its result by 2 to obtain the array dimension.\par
\par
Notes:\par
\par
This function can be useful when storing several sprites into the same array,\par
to know the exact offset of each frame.\par
\par
\par
Example:\par
\par
See DQBput example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsort SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsort (BYVAL ArraySeg, BYVAL ArrayOff, BYVAL NumRecords,\par
                     BYVAL RecordLen, IndexOff)\par
\par
Calling:\par
                \par
\lang1042\f1\u-1806?\lang1033\f0    ArraySeg    Segment of the array of integers to sort; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    ArrayOff    Offset of the array of integers to sort; use VARPTR\par
\lang1042\f1\u-1806?\lang1033\f0    NumRecords  Total number of records to sort\par
\lang1042\f1\u-1806?\lang1033\f0    RecordLen   Length of each record in bytes\par
\lang1042\f1\u-1806?\lang1033\f0    IndexOff    Offset of the integer index value within a record\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
DQBsort uses a fast bubble sort algorithm to sort a given array of records,\par
by comparing the index number (that must be an integer) of each record and\par
sorting the correspondent records from the lower value to the higher one of\par
it. The index field can be anywhere within the record, and you can specify\par
its position by using the IndexOff parameter, that is relative to the\par
beginning of a record (i.e. IndexOff=0 means the first field of a it).\par
RecordLen is the number of bytes of each record.\par
\par
Notes:\par
\par
A record can contain any type of data, and DQBsort will sort it by comparing\par
the index numbers. You can also sort a simple array of integers, by passing\par
2 as RecordLen (an integer is 2 bytes long) and 0 as IndexOff.\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBsPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBsPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                     BYVAL SpriteOff, BYVAL NewWidth, BYVAL NewHeight)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the sprite data; use VARPTR\par
\lang1042\f1\u-1806?\lang1033\f0    NewWidth    New sprite width in pixel units\par
\lang1042\f1\u-1806?\lang1033\f0    NewHeight   New sprite height in pixel units\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
DQBsPut works like DQBput, but allows to draw a scaled version of your sprite,\par
by specifying its new width and height; the sprite data is not modified during\par
this operation. This function also supports clipping and transparency.\par
\par
Notes:\par
\par
See DQBput, DQBfPut, DQBrPut and DQBbPut\par
\par
\par
Example:\par
\par
See DQBput example\par
\par
\par
-----------------------------------------------------------------------------\par
DQBstopVoice SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBstopVoice (BYVAL Voice)\par
\par
Calling:\par
                \par
\lang1042\f1\u-1806?\lang1033\f0    Voice       Voice to stop\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Stops any sound coming from specified voice; you can use this to stop a\par
looping sample...\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBtoggleBit FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBtoggleBit (BYVAL Value, BYVAL Bit)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Value       INTEGER value to toggle bit of\par
\lang1042\f1\u-1806?\lang1033\f0    Bit         Bit number to toggle\par
\par
Returns:\par
\par
An INTEGER value representing the original number with specified bit toggled.\par
\par
\par
Description:\par
\par
Toggles specified bit of the given number, and returns the result.\par
\par
Notes:\par
\par
See also DQBsetBit, DQBresetBit and DQBreadBit\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBtPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBtPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,\par
                     BYVAL SpriteOff, BYVAL BitMode)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    x           X position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    y           Y position of upper left corner of the sprite\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of the array holding the sprite data; use VARSEG\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of the array holding the sprite data; use VARPTR\par
\lang1042\f1\u-1806?\lang1033\f0    BitMode     Specifies which bitwise operation to perform\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
As normal DQBput, this routine draws a sprite on the given layer; but DQBtPut\par
allows you to apply a specified bitwise operation between each pixel of your\par
sprite and the background. Allowed modes are AND, OR and XOR, represented by\par
the numbers 1, 2 and 3 (you can use the BIT.AND, BIT.OR and BIT.XOR constants\par
here - see appendix A for a complete list of DQB constants). This function\par
supports both transparency and clipping.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBtri SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBtri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,\par
                    BYVAL x3, BYVAL y3, BYVAL Col)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the triangle\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x3          x coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y3          y coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    Col         color\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Draws a flat-shaded triangle with (x1,y1), (x2,y2) and (x3,y3) as vertex,\par
filled with specified color. DQBtri does not support transparency, but it's\par
affected by the clipping box.\par
\par
Notes:\par
\par
See also DQBgtri\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Draws 500 flat-shaded triangles\par
FOR i = 1 TO 500\par
  DQBtri VIDEO, (RND * 320), (RND * 200), (RND * 320), (RND * 200), (RND * 320), (RND * 200), (RND * 256)\par
NEXT i\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBttri SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBttri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,\par
                     BYVAL x3, BYVAL y3, BYVAL u1, BYVAL v1, BYVAL u2,\par
                     BYVAL v2, BYVAL u3, BYVAL v3, BYVAL TextureSeg,\par
                     BYVAL TextureOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the triangle\par
\lang1042\f1\u-1806?\lang1033\f0    x1          x coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y1          y coordinate of the first vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x2          x coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y2          y coordinate of the second vertex\par
\lang1042\f1\u-1806?\lang1033\f0    x3          x coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    y3          y coordinate of the third vertex\par
\lang1042\f1\u-1806?\lang1033\f0    u1          x coordinate of first vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    v1          y coordinate of first vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    u2          x coordinate of second vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    v2          y coordinate of second vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    u3          x coordinate of third vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    v3          y coordinate of third vertex on texture\par
\lang1042\f1\u-1806?\lang1033\f0    TextureSeg  Array segment holding the texture (use VARSEG)\par
\lang1042\f1\u-1806?\lang1033\f0    TextureOff  Array offset holding the texture (use VARPTR)\par
\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Draws a texture-mapped triangle with (x1,y1), (x2,y2) and (x3,y3) as vertexes.\par
The texture used must be stored into specified array with GET or DQBget, and\par
its width must be a power of 2, equal to the one specified by calling\par
DQBsetTextureSize (the default texture width is 64 pixels). Each vertex of\par
the triangle has also its own texture coordinates, that can be anywhere on\par
the texture itself, as well as out of it; if the distance between two texture\par
vertexes is greater than the texture size, the texture is wrapped while\par
drawing. DQBttri supports transparency (color 0 on the texture is *always*\par
handled as transparent color) and clipping.\par
\par
Notes:\par
\par
See also DQBsetTextureSize, DQBtri, DQBbtri, DQBgtri\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Dimension our 64x64 pixels texture array\par
DIM Texture(2049)\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
DQBinitVGA\par
\par
' Let's build our sample texture\par
FOR i = 0 TO 15\par
  DQBbox VIDEO, i, i, 63 - i, 63 - i, 31 - i\par
  DQBbox VIDEO, 16 + i, 16 + i, 47 - i, 47 - i, 16 + i\par
NEXT i\par
DQBbox VIDEO, 0, 0, 63, 63, 40\par
DQBline VIDEO, 0, 0, 63, 63, 4\par
DQBellipse VIDEO, 32, 32, 24, 24, 43\par
\par
' Gets our texture and clears the screen\par
DQBget VIDEO, 0, 0, 63, 63, VARSEG(Texture(0)), VARPTR(Texture(0))\par
DQBclearLayer VIDEO\par
\par
' Draws 500 textured triangles\par
FOR i = 1 TO 500\par
  DQBttri VIDEO, (RND * 320), (RND * 200), (RND * 320), (RND * 200), (RND * 320), (RND * 200), 0, 0, 63, 0, 0, 63, VARSEG(Texture(0)), VARPTR(Texture(0))\par
NEXT i\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBunpackBMap FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBunpackBMap (BYVAL PacketID, BYVAL BMap)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    PacketID    Packet ID number\par
\lang1042\f1\u-1806?\lang1033\f0    BMap        Blender map to load data into\par
\par
Returns:\par
\par
An INTEGER value holding the unpacking results:\par
\par
>   0     Operation successful\par
>   1     Datafile not yet opened\par
>   2     Unknown packet ID number\par
>   3     Bad password or unknown data\par
>   4     Blender map is not active\par
>   5     Incompatible blender map\par
\par
\par
Description:\par
\par
Decodes the blender map identified by specified packet ID number from the\par
currently opened datafile; blender map should be compatible with the bmap\par
structure where you're going to decode it onto (see DQBloadBMap for details).\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBopenDataFile\par
\par
\par
-----------------------------------------------------------------------------\par
DQBunpackCursor FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBunpackCursor (PacketID AS INTEGER, Cursor AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    PacketID    Packet ID number\par
\lang1042\f1\u-1806?\lang1033\f0    Cursor      64 characters string where to hold decoded cursor data\par
\par
Returns:\par
\par
An INTEGER value holding the unpacking results:\par
\par
>   0     Operation successful\par
>   1     Datafile not yet opened\par
>   2     Unknown packet ID number\par
>   3     Bad password or unknown data\par
\par
\par
Description:\par
\par
Decodes the mouse cursor identified by specified packet ID number from the\par
currently opened datafile, and stores it into the Cursor string, ready to be\par
used with the DQBsetMouseShape function.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBopenDataFile\par
\par
\par
-----------------------------------------------------------------------------\par
DQBunpackFont FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBunpackFont (PacketID AS INTEGER, Font AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    PacketID    Packet ID number\par
\lang1042\f1\u-1806?\lang1033\f0    Font        2305 characters string where to hold decoded font data\par
\par
Returns:\par
\par
An INTEGER value holding the unpacking results:\par
\par
>   0     Operation successful\par
>   1     Datafile not yet opened\par
>   2     Unknown packet ID number\par
>   3     Bad password or unknown data\par
\par
\par
Description:\par
\par
Decodes the font identified by specified packet ID number from the currently\par
opened datafile, and stores it into the Font string, ready to be used with\par
the DQBsetFont function.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBopenDataFile\par
\par
\par
-----------------------------------------------------------------------------\par
DQBunpackImage FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBunpackImage (BYVAL PacketID, BYVAL Layer, BYVAL x, BYVAL y)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    PacketID    Packet ID number\par
\lang1042\f1\u-1806?\lang1033\f0    Layer       Layer where to draw the image\par
\lang1042\f1\u-1806?\lang1033\f0    x           x coordinate where to begin drawing\par
\lang1042\f1\u-1806?\lang1033\f0    y           y coordinate where to begin drawing\par
\par
Returns:\par
\par
An INTEGER value holding the unpacking results:\par
\par
>   0     Operation successful\par
>   1     Datafile not yet opened\par
>   2     Unknown packet ID number\par
>   3     Bad password or unknown data\par
\par
\par
Description:\par
\par
Decodes the image identified by specified packet ID number from the currently\par
opened datafile, and draws it into the given layer, starting at (x,y). The\par
image packet does not include picture palette, so you'll have to set a palette\par
taken from another source (a palette packet from the same datafile, or any\par
other way you like). Also, this function does not support clipping, so it's\par
up to you to ensure that the image fits on the layer.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBopenDataFile\par
\par
\par
-----------------------------------------------------------------------------\par
DQBunpackPal FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBunpackPal (PacketID AS INTEGER, Pal AS STRING)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    PacketID    Packet ID number\par
\lang1042\f1\u-1806?\lang1033\f0    Pal         768 characters string to hold decoded palette data\par
\par
Returns:\par
\par
An INTEGER value holding the unpacking results:\par
\par
>   0     Operation successful\par
>   1     Datafile not yet opened\par
>   2     Unknown packet ID number\par
>   3     Bad password or unknown data\par
\par
\par
Description:\par
\par
Decodes the palette identified by specified packet ID number from the\par
currently opened datafile, and stores it into the Pal string. You can then\par
use it with all the other DQB palette handling functions.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBopenDataFile\par
\par
\par
-----------------------------------------------------------------------------\par
DQBunpackSound FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBunpackSound (BYVAL PacketID, BYVAL Slot)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    PacketID    Packet ID number\par
\lang1042\f1\u-1806?\lang1033\f0    Slot        Sound slot where to place decoded sound data\par
\par
Returns:\par
\par
An INTEGER value holding the unpacking results:\par
\par
>   0     Operation successful\par
>   1     Datafile not yet opened\par
>   2     Unknown packet ID number\par
>   3     Bad password or unknown data\par
>   4     Unknown sound slot\par
\par
\par
Description:\par
\par
Decodes the sound sample identified by specified packet ID number from the\par
currently opened datafile, and stores it into the given sound slot; it is\par
assumed that such a slot has been initialized with DQBinit. Decoded sounds\par
can then be normally played with DQBplaySound.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBopenDataFile\par
\par
\par
-----------------------------------------------------------------------------\par
DQBunpackSprite FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBunpackSprite (BYVAL PacketID, BYVAL SpriteSeg, BYVAL\par
                                  SpriteOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    PacketID    Packet ID number\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteSeg   Segment of QB array where to hold decoded sprite data\par
\lang1042\f1\u-1806?\lang1033\f0    SpriteOff   Offset of QB array where to hold decoded sprite data\par
\par
Returns:\par
\par
An INTEGER value holding the unpacking results:\par
\par
>   0     Operation successful\par
>   1     Datafile not yet opened\par
>   2     Unknown packet ID number\par
>   3     Bad password or unknown data\par
\par
\par
Description:\par
\par
Acts like DQBunpackImage, but stores decoded image data into the specified\par
QB array, ready to be used with DQBput or similar functions. Be sure you have\par
an array big enough to contain the data, otherwise you may crash your system.\par
\par
Notes:\par
\par
This works on image packets; this means you can call DQBunpackImage as well\par
as DQBunpackSprite on the same image packet.\par
\par
\par
Example:\par
\par
See DQBopenDataFile\par
\par
\par
-----------------------------------------------------------------------------\par
DQBunpackUser FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBunpackUser (BYVAL PacketID, BYVAL DataSeg, BYVAL DataOff)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    PacketID    Packet ID number\par
\lang1042\f1\u-1806?\lang1033\f0    DataSeg     Segment of QB array where to hold decoded user-defined data\par
\lang1042\f1\u-1806?\lang1033\f0    DataOff     Offset of QB array where to hold decoded user-defined data\par
\par
Returns:\par
\par
An INTEGER value holding the unpacking results:\par
\par
>   0     Operation successful\par
>   1     Datafile not yet opened\par
>   2     Unknown packet ID number\par
>   3     Bad password or unknown data\par
\par
\par
Description:\par
\par
Decodes an user defined packet data identified by specified packet ID number\par
from currently opened datafile into a QB array. User-defined packets can hold\par
any kind of binary data, limited only by the size, which must be 64K maximum.\par
The array where to place decoded data must be enough big to contain it,\par
otherwise you may crash your machine.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
See DQBopenDataFile\par
\par
\par
-----------------------------------------------------------------------------\par
DQBver FUNCTION\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE FUNCTION DQBver ()\par
\par
Calling:\par
\par
none\par
\par
Returns:\par
\par
An INTEGER value holding the library version\par
\par
\par
Description:\par
\par
DQBver returns the current DirectQB library version into an integer value. The\par
higher byte represents the major version, and the lower byte the minor version\par
number.\par
\par
Notes:\par
\par
You can also use DQBid$ to retrive a small string holding the library version\par
and my name, in case you want to display them.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE:'DIRECTQB.BI'\par
\par
' Let's initialize the library with no extra layers nor sounds nor EMS\par
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Finds major and minor library version numbers\par
major = DQBver \\ &H100\par
minor = DQBver AND &HFF\par
\par
' Prints them\par
PRINT "Current DirectQB version is" + STR$(major) + "." + LTRIM$(STR$(minor))\par
\par
' Prints the library identification string\par
PRINT DQBid$\par
\par
' Waits for the user to press a key\par
WHILE INKEY$ = "": WEND\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
-----------------------------------------------------------------------------\par
DQBwait SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBwait (BYVAL Times)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Times       Times to wait for the video vertical retrace\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Waits for the video vertical retrace Times times. It is suggested to wait for\par
the vertical retrace a time before drawing anything on the screen: this will\par
produce flickerless animations. The vertical retrace occurs 60 times per\par
second, so you can use this function also as delay routine.\par
\par
Notes:\par
\par
none\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBwaitKey SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBwaitKey (BYVAL ScanCode)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    Scancode    Scancode of the key to wait for\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Waits for the user to press the key specified by the scancode passed to the\par
function. DQBwaitKey works only if the keyboard interrupt handler has been\par
installed by calling DQBinstallKeyboard.\par
\par
Notes:\par
\par
See DQBinstallKeyboard, DQBkey, DQBreadKey\par
\par
\par
Example:\par
\par
none\par
\par
\par
-----------------------------------------------------------------------------\par
DQBxPut SUB\par
-----------------------------------------------------------------------------\par
\par
Prototype:\par
\par
DECLARE SUB DQBxPut (BYVAL SourceLayer, BYVAL x1, BYVAL y1, BYVAL x2,\par
                     BYVAL y2, BYVAL DestLayer, BYVAL x, BYVAL y)\par
\par
Calling:\par
\par
\lang1042\f1\u-1806?\lang1033\f0    SourceLayer   Layer where to get the sprite (source)\par
\lang1042\f1\u-1806?\lang1033\f0    x1            x position of upper left corner of the sprite on source\par
\lang1042\f1\u-1806?\lang1033\f0    y1            y position of upper left corner of the sprite on source\par
\lang1042\f1\u-1806?\lang1033\f0    x2            x position of lower right corner of the sprite on source\par
\lang1042\f1\u-1806?\lang1033\f0    y2            y position of lower right corner of the sprite on source\par
\lang1042\f1\u-1806?\lang1033\f0    DestLayer     Layer where to draw the sprite (destination)\par
\lang1042\f1\u-1806?\lang1033\f0    x             x position of upper left corner of the sprite on destination\par
\lang1042\f1\u-1806?\lang1033\f0    y             y position of upper left corner of the sprite on destination\par
\par
Returns:\par
\par
none\par
\par
\par
Description:\par
\par
Like normal DQBput, this function draws a sprite onto a specified layer, but\par
with a huge difference: DQBxPut does not require that you first get your\par
sprite into a QB array, as it automatically gets the data by assuming you\par
want to draw the sprite contained into the (x1,y1)-(x2,y2) box on the source\par
layer. Sprite data is directly copied into the destination layer at specified\par
(x,y) coordinates; this is great, but it has its weak spots... When both the\par
source and destination layers are on EMS, DQBxPut is slower than DQBput; in\par
addition it can only handle sprites with a height up to 50 pixels: higher\par
sprites will not be drawn (but there are no limits for the width).\par
\par
Notes:\par
\par
DQBxPut supports transparency and it's affected by the clipping box, so pixels\par
outside this box will not be drawn. It is strongly suggested that you use this\par
function to draw from an EMS layer onto a layer in base memory; this way you\par
can achieve almost the same speed of DQBput, without the need of extra memory\par
to hold the sprite. See also DQBput, DQBfPut, DQBsPut, DQBrPut and DQBbPut.\par
\par
\par
Example:\par
\par
*****************************************************************************\par
\par
' Here's a modified version of the DQBput example; this time we'll not use\par
' arrays to store our sprites...\par
\par
' All integers for speed\par
DEFINT A-Z\par
\par
'$INCLUDE: 'DIRECTQB.BI'\par
\par
' Let's initialize the library with two extra layers and no sounds nor EMS\par
IF DQBinit(2, 0, 0) THEN DQBclose: PRINT DQBerror$: END\par
\par
' Let's prepare our sprites on layer 2\par
FOR i = 0 TO 14\par
\par
  ' Draws a frame of our sprite\par
  DQBbox 2, (i * 16), 0, (i * 16) + 15, 15, 4\par
  DQBline 2, (i * 16) + (15-i), 15, (i * 16) + i, 0, 40\par
  DQBline 2, (i * 16) + 15, i, (i * 16), (15 - i), 40\par
\par
NEXT i\par
\par
DQBinitVGA\par
\par
FOR i = -16 TO 320\par
\par
  ' Empties layer 1\par
  DQBclearLayer 1\par
\par
  ' Finds what frame to draw\par
  Frame = ((i + 16) \\ 2) MOD 15\par
\par
  ' Draws our frame into layer 1\par
  DQBxPut 2, (Frame * 16), 0, (Frame * 16) + 15, 15, 1, i, 92\par
\par
  ' Waits for vertical retrace 1 time\par
  DQBwait 1\par
\par
  ' Copies layer 1 onto the screen\par
  DQBcopyLayer 1, VIDEO\par
\par
NEXT i\par
\par
' Ends program\par
DQBclose\par
\par
*****************************************************************************\par
\par
\par
=============================================================================\par
APPENDIX A - Library constants\par
=============================================================================\par
\par
To simplify the use of certain functions, the file DIRECTQB.BI contains some\par
useful constants. Here's the list:\par
\par
Constant name     Value   Can be used by\par
-----------------------------------------------------------------------------\par
TRUE              -1      General purpose, no specific function\par
FALSE             0       General purpose, no specific function\par
VIDEO             0       All the graphical functions that refer to a layer\par
B0                &H8000  All graphical functions to refer to 1st base layer\par
B1                &H8001  All graphical functions to refer to 2nd base layer\par
B2..B9     &H8002-&H8009  All graphical functions to refer to base layers 3-10\par
BSV               0       DQBsaveLayer to specify to save in BSAVE format\par
BMP               1       DQBsaveLayer to specify to save in BMP format\par
PCX               2       DQBsaveLayer to specify to save in PCX format\par
HOR               1       DQBmPut to draw horizontally flipped sprites\par
VER               2       DQBmPut to draw vertically flipped sprites\par
BIT.AND           1       DQBtPut to use AND bitwise operation between pixels\par
BIT.OR            2       DQBtPut to use OR bitwise operation between pixels\par
BIT.XOR           3       DQBtPut to use XOR bitwise operation between pixels\par
BOX               0       DQBsetCollideMethod to set bounding box check\par
PIXEL             1       DQBsetCollideMethod to set pixel-perfect check\par
FORWARD           0       DQBrotatePal to rotate palette forward\par
BACKWARD          1       DQBrotatePal to rotate palette backward\par
CENTERED          &H8000  DQBprint and DQBprints to center text on the screen\par
NONE              0       DQBsetTextStyle, DQBprints to specify no styles\par
SOLID             1       DQBsetTextStyle, DQBprints to specify solid style\par
BOLD              2       DQBsetTextStyle, DQBprints to specify bold style\par
ITALIC            4       DQBsetTextStyle, DQBprints to specify italic style\par
UNDERLINED        8       DQBsetTextStyle, DQBprints to specify underlined st.\par
BLENDED           16      DQBsetTextStyle, DQBprints to specify blended style\par
TEXTURED          32      DQBsetTextStyle, DQBprints to specify textured style\par
KEYANY            -1      DQBplayFLI, DQBwaitKey to specify any key\par
KEYESC            1       DQBkey to check the ESC key (see appendix B)\par
KEYENTER          28      DQBkey to check the ENTER key (see appendix B)\par
KEYSPACE          57      DQBkey to check the SPACE key (see appendix B)\par
KEYUP             72      DQBkey to check the up arrow key (see appendix B)\par
KEYDOWN           80      DQBkey to check the down arrow key (see appendix B)\par
KEYLEFT           75      DQBkey to check the left arrow key (see appendix B)\par
KEYRIGHT          77      DQBkey to check the right arrow key (see appendix B)\par
UP                0       DQBjoyMove to check if the joystick is moved up\par
DOWN              1       DQBjoyMove to check if the joystick is moved down\par
LEFT              2       DQBjoyMove to check if the joystick is moved left\par
RIGHT             3       DQBjoyMove to check if the joystick is moved right\par
JOY1              0       All the joystick routines to refer to joystick 1\par
JOY2              1       All the joystick routines to refer to joystick 2\par
GAMEPAD           2       All the joystick routines to refer to 4-buttons joys\par
BUTA              0       DQBjoyFire to check if joystick button A is pressed\par
BUTB              1       DQBjoyFire to check if joystick button B is pressed\par
BUTC              2       DQBjoyFire to check if gamepad button C is pressed\par
BUTD              3       DQBjoyFire to check if gamepad button D is pressed\par
AUTO              -1      DQBinstallSB to autodetect the soundcard settings\par
ONCE              0       DQBplaySound to play a sound once\par
LOOPED            1       DQBplaySound to play a sound repeatedly\par
ATTRIB.R          &H1     DQBdir$ attribute to search for read-only files\par
ATTRIB.H          &H2     DQBdir$ attribute to search for hidden files\par
ATTRIB.S          &H4     DQBdir$ attribute to search for system files\par
ATTRIB.L          &H8     DQBdir$ attribute to search for volume labels\par
ATTRIB.D          &H10    DQBdir$ attribute to search for directories\par
ATTRIB.A          &H20    DQBdir$ attribute to search for archive files\par
\par
\par
=============================================================================\par
APPENDIX B - Keyboard scancodes list\par
=============================================================================\par
\par
To check the state (pressed or released) of a certain key with the DQBkey\par
function, you must pass its keyboard scancode as parameter. For the most used\par
keys there're some constants that help you, so check out appendix A.\par
For the other keys, here's the complete list of scancodes for all them (please\par
note that a single scancode can represent more than a single key):\par
\par
Scancode  Key                           Scancode  Key\par
-----------------------------------------------------------------------------\par
 1        ESC                           44        Z\par
 2        1                             45        X\par
 3        2                             46        C\par
 4        3                             47        V\par
 5        4                             48        B\par
 6        5                             49        N\par
 7        6                             50        M\par
 8        7                             51        , or <\par
 9        8                             52        . or >\par
10        9                             53        / or ?\par
11        0                             54        RIGHT SHIFT\par
12        - or _                        55        * or PRINT SCREEN\par
13        = or +                        56        ALT (RIGHT and LEFT)\par
14        BACKSPACE                     57        SPACE\par
15        TAB                           58        CAPSLOCK\par
16        Q                             59        F1\par
17        W                             60        F2\par
18        E                             61        F3\par
19        R                             62        F4\par
20        T                             63        F5\par
21        Y                             64        F6\par
22        U                             65        F7\par
23        I                             66        F8\par
24        O                             67        F9\par
25        P                             68        F10\par
26        [ or \{                        69        NUMLOCK\par
27        ] or \}                        70        SCROLL LOCK\par
28        ENTER                         71        7 or HOME\par
29        CONTROL (RIGHT and LEFT)      72        8 or UP\par
30        A                             73        9 or PAGE UP\par
31        S                             74        -\par
32        D                             75        4 or LEFT\par
33        F                             76        5\par
34        G                             77        6 or RIGHT\par
35        H                             78        +\par
36        J                             79        1 or END\par
37        K                             80        2 or DOWN\par
38        L                             81        3 or PAGE DOWN\par
39        ; or :                        82        0 or INSERT\par
40        ' or "                        83        . or DEL\par
41        \\ or ~                        87        F11\par
42        LEFT SHIFT                    88        F12\par
\par
\par
=============================================================================\par
APPENDIX C - Library file formats\par
=============================================================================\par
\par
General File Format\par
\pard\nowidctlpar\sa200\sl276\slmult1\f2 ----------------------\par
\f0 Byte 0: \ldblquote GSL File\rdblquote\par
Byte 8: Offset to File information\par
Byte 12: Length of full file\par
Byte 16: File Checksum\par
File Table:\par
Byte 20: File Table size\par
Byte 24: Number of Data Packets\par
Byte 28: Offset to name list\par
Byte 32: Offset to type list\par
Byte 36: Offset to number list\par
Name list:\par
Byte x+0: Name list size\par
Byte x+4: Minimum name check bytes\par
Byte x+6: LASCIZ Name0, LASCIZ Name1, etc.\par
Byte last: Zero(0000h)\par
Type list:\par
Byte x+0: Type list size\par
Byte x+6: LASCIZ Typex, LASCIZ Typey, etc.\par
Byte last: Zero(0000h)\par
Number list:\par
Byte x+0: Name list size\par
Byte x+4: NumList0, NumList0, etc.\par
Byte last: Zero(0000h)\par
Numlist-\par
Byte x+0: Offset to Name\par
Byte x+4: Data Packet Type\par
Byte x+8: Offset to Data Packet Type name\par
Byte x+12: Offset to Data Packet\par
Byte x+16: Data Packet size\par
Data Packet:\par
Byte x+0: Data Packet Type\par
Byte x+2: Data Packet size\par
Byte x+6: Data(that is needed)\par
File information:\par
Byte x: LASCIZ File Name\par
Byte y: LASCIZ Author Name\par
Byte z: LASCIZ Package Name\par
Byte ?: etc.\par
\pard\nowidctlpar\f2 -----------------------------------------------------------------------------\par
\f0 The palette data format\par
-----------------------------------------------------------------------------\par
\par
The palette parameter used by DQBsetPal, DQBgetPal, DQBfadeIn, DQBloadLayer\par
and DQBsaveLayer must be a string of 768 character. This string holds the\par
hues data for each of the 256 colors: three bytes per color, representing\par
the red, green and blue intensities ranging 0-63. So if you want to know the\par
green intesity of color 45 of given palette stored into the Pal string, here's\par
the simple code:\par
\par
green = ASC(MID$(Pal, ((45 * 3) + 2), 1))\par
                        |         |\par
                        |          \\ Change this with 1,2 or 3 to know the\par
                        |            red, green and blue hues\par
                         \\ This is the color number; let's multiply it by 3\par
                          \par
\par
-----------------------------------------------------------------------------\par
The mouse cursor data format\par
-----------------------------------------------------------------------------\par
\par
When calling DQBsetMouseShape, you must pass a string of 64 characters as the\par
third parameter; this represents the cursor shape data.\par
Each cursor shape is a 16x16 pixels bitmap, composed of two masks of bits: the\par
so called "screen mask" and "cursor mask". The data is stored so that the\par
first 32 bytes of our string are the screen mask, and the other 32 are the\par
cursor mask. Two bytes (16 bits) make a cursor line, so we have 64 bytes\par
to define the two 16x16 pixels masks.\par
The screen mask specifies what part of the cursor is to be the shape and what\par
part is to be the background: a 0 means the background, a 1 means the shape.\par
The cursor mask tells what color to use into the mask. By combining these two\par
masks, the cursor is drawn onto the screen. Here are the combinations, with\par
their results on the screen:\par
\par
Bit on screen mask            Bit on cursor mask          Pixel drawn\par
0                             0                           Black\par
0                             1                           White\par
1                             0                           Transparent\par
1                             1                           Inverted\par
\par
I know it's hard, but it's even harder to explain... I'll try to make an\par
example. Let's look at the data below: this represents the default DirectQB\par
mouse cursor (the arrow).\par
\par
&HFF,&H3F,&HFF,&H1F,&HFF,&H0F,&HFF,&H07     \\\par
&HFF,&H03,&HFF,&H01,&HFF,&H00,&H7F,&H00      |\par
&H3F,&H00,&H7F,&H00,&HFF,&H0F,&HFF,&HBF      |--- Screen mask\par
&HFF,&HFF,&HFF,&HFF,&HFF,&HFF,&HFF,&HFF     /\par
&H00,&H00,&H00,&H40,&H00,&H60,&H00,&H70     \\\par
&H00,&H78,&H00,&H7C,&H00,&H7E,&H00,&H7F      |\par
&H80,&H7F,&H00,&H70,&H00,&H40,&H00,&H00      |--- Cursor mask\par
&H00,&H00,&H00,&H00,&H00,&H00,&H00,&H00     /\par
\par
Let's examine the bytes of our masks: just remember that of the two bytes that\par
make a cursor line, the first represents the last 8 pixels, and the second the\par
first 8.\par
\par
Screen mask                             Cursor mask\par
\par
&HFF,&H3F =   0011111111111111          &H00,&H00 =   0000000000000000\par
&HFF,&H1F =   0001111111111111          &H00,&H40 =   0100000000000000\par
&HFF,&H0F =   0000111111111111          &H00,&H60 =   0110000000000000\par
&HFF,&H07 =   0000011111111111          &H00,&H70 =   0111000000000000\par
&HFF,&H03 =   0000001111111111          &H00,&H78 =   0111100000000000\par
&HFF,&H01 =   0000000111111111          &H00,&H7C =   0111110000000000\par
&HFF,&H00 =   0000000011111111          &H00,&H7E =   0111111000000000\par
&H7F,&H00 =   0000000001111111          &H00,&H7F =   0111111100000000\par
&H3F,&H00 =   0000000000111111          &H80,&H7F =   0111111110000000\par
&H7F,&H00 =   0000000001111111          &H00,&H70 =   0111000000000000\par
&HFF,&H0F =   0000111111111111          &H00,&H40 =   0100000000000000\par
&HFF,&HBF =   1011111111111111          &H00,&H00 =   0000000000000000\par
&HFF,&HFF =   1111111111111111          &H00,&H00 =   0000000000000000\par
&HFF,&HFF =   1111111111111111          &H00,&H00 =   0000000000000000\par
&HFF,&HFF =   1111111111111111          &H00,&H00 =   0000000000000000\par
&HFF,&HFF =   1111111111111111          &H00,&H00 =   0000000000000000\par
\par
The hotspot is passed to DQBsetMouseShape in pixel units. A hotspot of (0,0)\par
represents the upper-left corner of the cursor bitmap; the hotspot coordinates\par
can range from (-16,-16) to (16,16).\par
\par
Now I know that it's not so easy to create a mouse cursor, so I made the\par
CUREDIT program, which is a cursor editor. You can use it to create and save\par
your cursors as DATA statements as well as into a binary file as strings of\par
64 characters.\par
\par
\par
-----------------------------------------------------------------------------\par
The font data format\par
-----------------------------------------------------------------------------\par
\par
A font is contained into a string of 2305 characters. Each font holds the\par
graphical data for 256 characters (8 bytes per each character, so we have\par
8*256=the first 2048 bytes), the width in pixels of each of them (next 256\par
bytes, 1 byte for each character), and the height of all the characters (last\par
byte).\par
Each bit of the 8 bytes of graphical data of a character represents the state\par
of a pixel: 1 means the pixel is on, 0 that the pixel is off.\par
So let's examine the data for the following character:\par
\par
00010000 =  &H10\par
00111000 =  &H38\par
01101100 =  &H6C\par
01101100 =  &H6C\par
11000110 =  &HC6\par
11111110 =  &HFE\par
11000110 =  &HC6\par
00000000 =  &H00\par
\par
This would obviously represent an 'A'...\par
The pixels off will be transparent if in transparent text mode, otherwise it\par
will be set to the current text background color set by DQBsetTextBackCol.\par
\par
Old fixed-sized fonts are no longer supported by DQBsetFont.\par
Use DirectQB Tools to create your own fonts; old fonts can be still loaded\par
from this utility, so you can use it to convert them into the new format.\par
\par
\par
-----------------------------------------------------------------------------\par
The blender map data format\par
-----------------------------------------------------------------------------\par
\par
Creating a blender map is often a slow process. For this reason, I've coded\par
the DQBloadBMap and DQBsaveBMap functions; here follows the file format\par
description:\par
\par
Offset  Length  Description\par
0       4       Blender map file format ID string; must be "BMap"\par
4       1       First mapped foreground color\par
5       1       Last mapped foreground color\par
6       256*n   n blender map chunks, where n is the total number of mapped\par
                foreground colors\par
\par
A blender map chunk is a 256 bytes chunk that contains all the 256 possible\par
background color combination for a foreground color.\par
\par
\par
-----------------------------------------------------------------------------\par
The datafile file format\par
-----------------------------------------------------------------------------\par
\par
DirectQB datafiles are a little complex structures. The first 1032 bytes are\par
the header, here explained:\par
\par
Offset  Length  Description\par
0       7       Datafile file format ID string: must be "DQBPaCk"\par
7       1       Number of used packets\par
8       1024    256 packet offset info chunks; each of these is a 4 bytes\par
                long integer, specifying the absolute address of the packet\par
                data into the file\par
\par
Next the packets data follow. Each packet type has its own small header, and\par
all them are encoded and encrypted using the same algorithm: basically it's\par
a simple RLE-based engine, where every time a byte has to be repeated, a\par
255 is the marker byte, next follow the number of repetitions (up to 255), and\par
the byte to repeat. If a single byte 255 has to decoded, the encoded stream\par
would look like "255,1,255"; that's all. About encryption, here's how it\par
works: before RLE-decoding the data stream, the password bytes are\par
"subtracted" from the encoded data, and this is repeated beginning with\par
subtracting the first password character to the first packet byte, and then\par
until the end of the packet, wrapping the password. Needless to say, when\par
no password is specified, this process has no effect. The password is not\par
stored into the datafile itself, so it's up to you to remind it, otherwise\par
you may loose your data! I know this is also a simple algorithm, but it works\par
quickly and it's hard to decode.\par
Now, here follows an explanation of the different packets allowed into a\par
datafile. I refer to them as they should be once decrypted and decoded:\par
\par
* FONT packet\par
\par
    Offset  Length  Description\par
    0       4       Packet ID: must be "FNT\lang1042\f1\u-1806?\lang1033\f0 "\par
    4       2305    Font data\par
\par
* IMAGE packet\par
\par
    Offset  Length  Description\par
    0       4       Packet ID: must be "IMG\lang1042\f1\u-1806?\lang1033\f0 "\par
    4       2       Image width in pixels\par
    6       2       Image height in pixels\par
    8       ?       Image data\par
\par
* SOUND packet\par
\par
    Offset  Length  Description\par
    0       4       Packet ID: must be "SND\lang1042\f1\u-1806?\lang1033\f0 "\par
    4       4       Sound length in bytes\par
    8       ?       Sample data\par
\par
* PALETTE packet\par
\par
    Offset  Length  Description\par
    0       4       Packet ID: must be "PAL\lang1042\f1\u-1806?\lang1033\f0 "\par
    4       768     Palette data\par
\par
* BMAP packet\par
\par
    Offset  Length  Description\par
    0       4       Packet ID: must be "BMA\lang1042\f1\u-1806?\lang1033\f0 "\par
    4       1       Number of mapped foreground color\par
    5       ?       Blender map data\par
\par
* CURSOR packet\par
\par
    Offset  Length  Description\par
    0       4       Packet ID: must be "CUR\lang1042\f1\u-1806?\lang1033\f0 "\par
    4       64      Cursor data\par
\par
* USER packet\par
\par
    Offset  Length  Description\par
    0       4       Packet ID: must be "USR\lang1042\f1\u-1806?\lang1033\f0 "\par
    4       4       Data length\par
    8       ?       Any data\par
\par
\par
\par
=============================================================================\par
APPENDIX D - Known bugs\par
=============================================================================\par
\par
I've worked a lot to fix all the possible bugs of this library. Anyway I'm\par
not sure DirectQB is totally bug-free.\par
The main "bug" I've found is with the mouse initialization when calling\par
DQBinit. Sometimes on my K6-200 it locks up the machine, and you have to\par
reboot; this seems not to happen on my notebook with external mouse (Logitech),\par
so I'm supposing it's a mouse driver problem, also because theoretically my\par
code should work...\par
Again about the mouse, I've reported that the hotspot setting when calling\par
DQBsetMouseShape fails under Windows 95: to obtain the correct X hotspot\par
coordinate you must multiply your value by 2 and then pass it to the function.\par
This is very strange as all works ok when running the same code under plain\par
DOS, so I've not fixed it.\par
I've not found any more bugs on the library as by now; if you find others,\par
please let me know, and I'll try to fix them.\par
\par
\par
=============================================================================\par
APPENDIX E - Versions history\par
=============================================================================\par
\par
version 1.0                 First version of DirectQB, with no sound support,\par
August, the 30th 1998       a mouse cursor editor plus a demo of the library.\par
                            DQBget and DQBput use a custom sprite data format,\par
                            which is not compatible with standard GET and PUT.\par
\par
version 1.1                 After a month of waitings, version 1.1 brings a\par
October, the 3rd 1998       limited sound support, as only a sound effect can\par
                            be played at once. Sounds are stored and played\par
                            directly from EMS; the user just calls a function\par
                            to load and another one to play them. DQBget and\par
                            DQBput are now compatible with GET and PUT, and\par
                            DQBput has been optimized a lot. Also added an\par
                            even faster DQBfastPut, plus a DQBscaledPut\par
                            routines. Other functions here and there, plus a\par
                            working-on one to draw gouraud shaded triangles.\par
\par
version 1.11                The sound engine bug has been fixed! Now you can\par
October, the 5th 1998       play up to 8 sound effects simultaneously!!\par
                            Also added customizable volume setting for each\par
                            of the eight voices...\par
\par
version 1.2                 Added a lot of new routines. DirectQB now supports\par
October, the 27th 1998      roto-zooming effects, as well as color blending.\par
                            With the new blender map system, you can now build\par
                            virtually any color effect; also fixed some bugs\par
                            here and there, and added some extra sound handing\par
                            routines.\par
\par
version 1.3                 Mainly internal enhancements; added an int 24h\par
November, the 15th 1998     handler for critical DOS errors. DQBxPut draws a\par
                            sprite without using external QB arrays, saving\par
                            memory; new faster DQBprint function now supports\par
                            non-fixed sized fonts, as well as different print\par
                            styles (normal, bold, italic, or underlined).\par
                            DirectQB has its first 3D functions! DQBtri and\par
                            DQBgtri draw flat-shaded and gouraud-shaded\par
                            triangles very quickly.\par
\par
version 1.31                Finally added texture mapped triangle support;\par
November, the 23th 1998     most of the graphical functions have been\par
                            accelerated a little, plus other minor changes...\par
\par
version 1.4                 No more DQBlite! Now the entire library is split\par
December, the 18th 1998     into 15 object files, so you can build your own\par
                            custom version of DQB, only with the functions\par
                            that you actually use! Added color blending\par
                            support to all the triangle functions, a fliped\par
                            put routine and support for layers in conventional\par
                            memory. In addition, from this release the library\par
                            will be shared without executables nor the LIB and\par
                            QLB files; anyway there's an utility that helps\par
                            you building these last ones.\par
\par
version 1.41                Small bugfixed, and the new DQBpaint function\par
December, the 22nd 1998     added. Nothing more to report...\par
\par
version 1.42                Another maintenance release, with lot of small\par
December, the 29th 1998     bugs fixed; base layers are now automatically\par
                            allocated in conventional memory, and finally they\par
                            work... Also added two new joystick routines, and\par
                            the MAKEDQB utility have been almost recoded\par
                            always to do its job perfectly, and to be modified\par
                            in an easier way.\par
\par
version 1.5                 Major changes! Sound engine now supports sound\par
March, the 25th 1999        resampling! Added the DQBscrollArea function, plus\par
                            a high precision timer, pixel-perfect collision\par
                            detection, a fast FLI player, and new font\par
                            routines (now also with support for textured\par
                            text!). Also lots of general purpose functions;\par
                            the library has been speeded up a little, and\par
                            there are several bug-fixes. The DQBMAKE batch\par
                            utility has been replaced by the user-friendly\par
                            DirectQB Library Manager program, that allows you\par
                            to select each module to add to your copy of DQB,\par
                            and builds an optimized DIRECTQB.BI file for you\par
                            automatically.\par
\par
version 1.51                Minor bugfixes, plus the new DQBcollideOnLayer\par
April, the 8th 1999         function, and the DQB Library Manager 1.1, with\par
                            autodetection of your QuickBasic 4.5 directory.\par
\par
version 1.6                 Major, and maybe last DirectQB release. Added\par
May, the 29th 1999          support for up to 10 blender maps active at the\par
                            same time, datafiles, improved sound quality,\par
                            any size image load/save, new layer copy routines,\par
                            improved font routines, support for Windows long\par
                            filenames, many bugfixes and the new DQB DataFile\par
                            Encoder program. Also the bug with the DQB Library\par
                            Manager directory finder has been fixed.\par
\par
version 1.61                Minor bugfixes, DQBpPut function added, datafile\par
June, the 1st 1999          handling routines modified to work with numbers\par
                            as packet IDs instead of strings\par
\par
version 1.7                 DQBfpu subroutine added, Tri routine clipping bug\par
September, the 4th 2000     fixed, Palette searching fixed\par
\par
version 1.71                Added DQBsetFreq\par
April, the 16th 2002\par
\par
 \par
\par
=============================================================================\par
APPENDIX F - Inside library modules\par
=============================================================================\par
\par
Here's the list of functions contained in each of the OBJ files that make\par
the DirectQB library. Every time you'll use a function, you'll need the\par
correspondent module, that will be also linked to your final program\par
executable file. By default, all these modules are included into the library;\par
you can build your own custom set of routines by combining them. See section\par
1.5 of this manual for details.\par
\par
MAIN.OBJ        - DQBinit, DQBfpu, DQBver, DQBmapLayer, DQBclose, DQBsort, DQBinitVGA,\par
                  DQBinitText, DQBsetBaseLayer, DQBcopyLayer, DQBclearLayer,\par
                  DQBwait, DQBsetFrameRate, DQBframeReady, DQBangle, DQBerror$\par
                  DQBid$, DQBpeek, DQBpoke\par
DRAW.OBJ        - DQBcopyTransLayer, DQBcopyHitLayer, DQBpset, DQBpoint,\par
                  DQBline, DQBgline, DQBellipse, DQBbox, DQBboxf, DQBpaint,\par
                  DQBscroll, DQBscrollArea, DQBsetTransPut, DQBsetSolidPut,\par
                  DQBget, DQBput\par
IMAGE.OBJ       - DQBloadImage, DQBsaveImage, DQBplayFLI, DQBopenFLI,\par
                  DQBplayFLIstep, DQBcloseFLI\par
SPRITE.OBJ      - DQBsize, DQBsetClipBox, DQBsPut, DQBrPut, DQBfPut, DQBxPut,\par
                  DQBmPut, DQBhPut, DQBtPut, DQBpPut, DQBputOver, DQBcollide,\par
                  DQBcollideOnLayer, DQBsetCollideMethod\par
BIT.OBJ         - DQBsetBit, DQBresetBit, DQBreadBit, DQBtoggleBit,\par
                  DQBshiftLeft, DQBshiftRight\par
PALETTE.OBJ     - DQBsetCol, DQBgetCol, DQBfindCol, DQBfindPalCol, DQBsetPal,\par
                  DQBgetPal, DQBfadeIn, DQBfadeStepIn, DQBfadeTo,\par
                  DQBfadeStepTo, DQBpalOff, DQBpalRotate\par
FONT.OBJ        - DQBprint, DQBprints, DQBlen, DQBsetBIOSfont, DQBsetFont,\par
                  DQBsetTextBackCol, DQBsetTextStyle, DQBsetFontTexture,\par
                  DQBloadFont, DQBsetTextSpacing, DQBsetTextBMap\par
DISK.OBJ        - DQBdir$, DQBdrive$, DQBpath$, DQBnumDrives, DQBsetDrive$,\par
                  DQBchDir\par
BLENDING.OBJ    - DQBfilterBox, DQBbPut, DQBcreateBMap, DQBsetBMap, DQBgetBMap,\par
                  DQBcopyBlendLayer, DQBloadBMap, DQBsaveBMap, DQBremoveBMap\par
KEYBOARD.OBJ    - DQBinstallKeyboard, DQBremoveKeyboard, DQBkey, DQBreadKey,\par
                  DQBwaitKey, DQBasc, DQBinkey$\par
JOYSTICK.OBJ    - DQBjoyDetected, DQBpollJoy, DQBjoyX, DQBjoyY, DQBjoyMove,\par
                  DQBjoyFire, DQBresetJoy, DQBsetJoySens\par
MOUSE.OBJ       - DQBmouseDetected, DQBmouseX, DQBmouseY, DQBmouseLB,\par
                  DQBmouseRB, DQBsetMousePos, DQBmouseShow, DQBmouseHide\par
                  DQBsetMouseRange, DQBsetMouseShape, DQBsetMouseSpeed,\par
                  DQBresetMouse\par
SOUND.OBJ       - DQBinstallSB, DQBloadSound, DQBloadRawSound, DQBplaySound,\par
                  DQBinUse, DQBpauseSound, DQBresumeSound, DQBstopVoice,\par
                  DQBsetVoiceVol, DQBremoveSB, DQBsetVolume\par
3D.OBJ          - DQBtri, DQBgtri, DQBttri, DQBbtri, DQBbgtri, DQBbttri,\par
                  DQBfttri, DQBsetTextureSize\par
DATAFILE.OBJ    - DQBopenDataFile, DQBunpackImage, DQBunpackSprite,\par
                  DQBunpackSound, DQBunpackPalette, DQBunpackBMap,\par
                  DQBunpackFont, DQBunpackCursor, DQBunpackUser,\par
                  DQBcloseDataFile\par
\par
\par
=============================================================================\par
APPENDIX G - Error messages\par
=============================================================================\par
\par
DirectQB has a built-in error messaging system; this means that whenever a\par
function fails, other than the error code returned by the function itself, an\par
error message is stored into a string that can be retrieved at any time, by\par
simply calling DQBerror$. You can use this function to prompt the user for\par
the exact error occured, without having to write your own custom error\par
handler, to handle all the possible DQB error messages. An example on using\par
this system follows here:\par
\par
' ... suppose you want to initialize the library with 7 layers, 5 sounds\par
' and 120 KB of free EMS memory:\par
IF DQBinit(7, 5, 120) THEN DQBclose: PRINT DQBerror$: END\par
' If we get here, DQB was successfully initialized\par
\par
If the DQBinit call fails (almost all the DQB functions return a non-zero\par
value on errors), DQBclose is called to avoid possible conflicts, and then the\par
proper error message is prompted to the user, and the program ends. What is\par
stored into DQBerror$ here depends on the function that failed; take a look at\par
the table below for a list of all the possible error messages:\par
\par
Error message:                      May be caused by function:\par
\par
"Library already initialized"       DQBinit\par
"386 or better CPU not found"       DQBinit\par
"No EMM driver detected"            DQBinit\par
"Not enough free EMS memory"        DQBinit\par
"Unable to open file"               DQBloadImage, DQBplayFLI, DQBloadFont,\par
                                    DQBloadBMap, DQBloadSound, DQBloadRawSound\par
"General file reading error"        DQBloadImage, DQBplayFLI, DQBloadFont,\par
                                    DQBloadBMap, DQBloadSound, DQBloadRawSound\par
"Blender map already allocated"     DQBcreateBMap\par
"Not enough free base memory"       DQBsetBaseLayer, DQBplayFLI, DQBcreateBMap,\par
                                    DQBinstallSB\par
"Blender map is not active"         DQBloadBMap, DQBsaveBMap\par
"Cannot create file"                DQBsaveImage, DQBsaveBMap\par
"General file writing error"        DQBsaveImage, DQBsaveBMap\par
"Unknown or bad file format"        DQBloadImage, DQBplayFLI, DQBloadSound\par
"No sounds initialized"             DQBinstallSB\par
"DMA channel not supported"         DQBinstallSB\par
"Failed to reset sound card DSP"    DQBinstallSB\par
"High mixing speed not supported"   DQBinstallSB\par
"Old sound card not supported"      DQBinstallSB\par
"File format not supported"         DQBloadSound\par
"Sound exceed 64k size limit"       DQBloadSound\par
"Unknown sound slot"                DQBloadSound, DQBloadRawSound,\par
                                    DQBunpackSound\par
"Cannot read past end of file"      DQBloadRawSound\par
"Can't open two FLI files at once"  DQBplayFLI, DQBopenFLI\par
"Incompatible blender map"          DQBloadBMap, DQBunpackBMap\par
"BLASTER variable not set"          DQBinstallSB\par
"Sound engine not yet initialized"  <reserved for future use>\par
"Datafile not yet opened"           DQBunpackFont, DQBunpackImage,\par
                                    DQBunpackSprite, DQBunpackSound,\par
                                    DQBunpackBMap, DQBunpackPal,\par
                                    DQBunpackCursor, DQBunpackUser\par
"Unknown packet ID"                 DQBunpackFont, DQBunpackImage,\par
                                    DQBunpackSprite, DQBunpackSound,\par
                                    DQBunpackBMap, DQBunpackPal,\par
                                    DQBunpackCursor, DQBunpackUser\par
"Bad password or corrupted data"    DQBunpackFont, DQBunpackImage,\par
                                    DQBunpackSprite, DQBunpackSound,\par
                                    DQBunpackBMap, DQBunpackPal,\par
                                    DQBunpackCursor, DQBunpackUser\par
"Can't open two datafiles at once"  DQBopenDataFile\par
"Operation successful"              Guess?\par
\par
\par
=============================================================================\par
Credits and final words\par
=============================================================================\par
\par
DirectQB has been coded by Angelo Mottola of Enhanced Creations 1998-99\par
\par
Updates 1.7+ done by:\par
  Devin Garner\par
  speige@hotmail.com\par
  39016533 - icq\par
\par
Update 1.71 done by WisdomDude\par
  \par
Special thanks go to:\par
\par
Petter Holmberg - for the original QB version of the core algorithm used for\par
          DQBpaint, many other hints and for his constant help and interest\par
          in my work\par
V1CTOR - DQBfpu\par
Rich Geldreich - for the original QB algorithm used by DQBellipse\par
The PC Game Programmers Encyclopedia - as an infinite source of informations\par
Peter Norton - for his great online guide to assembly language\par
Ralph Brown - for his huge and detailed list of DOS interrupts\par
\par
...and all of you on the EC wwwboard and on ICQ for your constant support\par
and your many suggestions that bring me to constantly improve DQB.\par
\par
If you have any hints, suggestions or bug reports, please contact me using\par
one of the following methods:\par
\par
                       E-mail: angelillo@bigfoot.com\par
                               ICQ: 24084401\par
                  ICQ pager: 24084401@pager.mirabilis.com\par
\par
Visit also the Enhanced Creations Homepage located at:\par
\par
                        http://www.ecplusplus.com\par
\par
DirectQB is freeware. The only thing I'm asking you is that you write my name\par
somewhere in the credits section of your games if you use it.\par
Once finished, it would be nice for me to see your work!\par
\par
Thanks for using DirectQB, and please excuse my bad English!\f2\fs21\par
}
 